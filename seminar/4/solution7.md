### **Решение задачи 7:**

**Задача:** Для каждого отрезка определить количество других отрезков, с которыми он пересекается.

**Метод:** Сортировка и бинарный поиск для подсчёта непересекающихся отрезков.

---

### **Алгоритм**
1. **Сортировка отрезков:**
    - Отсортируем отрезки по правому концу (`r`).
    - Отсортируем отрезки по левому концу (`l`).

2. **Подсчёт непересекающихся отрезков:**  
   Для каждого отрезка `[l_i, r_i]`:
    - Количество отрезков, заканчивающихся до `l_i` (не пересекаются слева): `count_left`.
    - Количество отрезков, начинающихся после `r_i` (не пересекаются справа): `count_right`.
    - Общее количество пересекающихся отрезков:  
      `result[i] = (n - 1) - (count_left + count_right)`.

3. **Бинарный поиск:**  
   Используется для быстрого подсчёта `count_left` и `count_right`.

---

### **Пример кода**
```java
public static int[] countIntersectingSegments(int[] l, int[] r) {
    int n = l.length;
    int[] result = new int[n];
    
    // Массивы для сортировки по правому и левому концам
    int[][] byRight = new int[n][2];
    int[][] byLeft = new int[n][2];
    for (int i = 0; i < n; i++) {
        byRight[i][0] = r[i];
        byRight[i][1] = l[i];
        byLeft[i][0] = l[i];
        byLeft[i][1] = r[i];
    }
    
    // Сортировка по правому концу
    Arrays.sort(byRight, (a, b) -> {
        if (a[0] != b[0]) return Integer.compare(a[0], b[0]);
        return Integer.compare(a[1], b[1]);
    });
    
    // Сортировка по левому концу
    Arrays.sort(byLeft, (a, b) -> {
        if (a[0] != b[0]) return Integer.compare(a[0], b[0]);
        return Integer.compare(a[1], b[1]);
    });
    
    // Извлекаем отсортированные правые и левые концы
    int[] rSorted = new int[n];
    int[] lSorted = new int[n];
    for (int i = 0; i < n; i++) {
        rSorted[i] = byRight[i][0];
        lSorted[i] = byLeft[i][0];
    }
    
    // Для каждого отрезка считаем количество пересечений
    for (int i = 0; i < n; i++) {
        int currentL = l[i];
        int currentR = r[i];
        
        // Количество отрезков, заканчивающихся до currentL
        int countLeft = binarySearchCount(rSorted, currentL);
        
        // Количество отрезков, начинающихся после currentR
        int countRight = lSorted.length - binarySearchCount(lSorted, currentR + 1);
        
        result[i] = (n - 1) - (countLeft + countRight);
    }
    
    return result;
}

// Возвращает количество элементов в массиве, строго меньших value
private static int binarySearchCount(int[] arr, int value) {
    int low = 0;
    int high = arr.length;
    while (low < high) {
        int mid = (low + high) / 2;
        if (arr[mid] < value) {
            low = mid + 1;
        } else {
            high = mid;
        }
    }
    return low;
}
```

---

### **Объяснение**
- **Сортировка:**  
  Отрезки сортируются дважды: по правому и левому концам. Это позволяет эффективно находить непересекающиеся отрезки.

- **Бинарный поиск:**
    - `countLeft` — количество отрезков, у которых `r_j < l_i` (не пересекаются слева).
    - `countRight` — количество отрезков, у которых `l_j > r_i` (не пересекаются справа).

- **Формула:**  
  Общее число пересекающихся отрезков для `i` равно общему числу отрезков минус 1 (сам `i`) и минус количество непересекающихся.

---

### **Пример работы**
**Входные данные:**  
Отрезки: `[1, 3]`, `[2, 4]`, `[5, 7]`.

**Результат:**
- Для `[1, 3]`: 1 пересечение (`[2, 4]`).
- Для `[2, 4]`: 1 пересечение (`[1, 3]`).
- Для `[5, 7]`: 0 пересечений.

---

### **Сложность**
- **Время:**
    - Сортировка: O(n log n).
    - Бинарный поиск для каждого отрезка: O(n log n).  
      Итоговая сложность: **O(n log n)**.
- **Память:** O(n) для хранения отсортированных массивов.

---

### **Ключевые моменты**
- **Эффективность:** Алгоритм обрабатывает 10⁵ отрезков за время, близкое к O(n log n).
- **Корректность:** Учитывает все случаи пересечений, включая вложенные и касательные отрезки.
- **Оптимизация:** Использует бинарный поиск для быстрого подсчёта непересекающихся отрезков.