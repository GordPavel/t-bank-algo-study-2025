### **Подробная теория решения задач RSQ для многомерных массивов**

---

#### **1. Одномерный случай (1a)**
**Задача:** Найти сумму элементов на отрезке `[l, r]` за O(1) после предподсчёта.

**Метод:** Префиксные суммы (Prefix Sum Array).

**Теория:**
- **Префиксный массив** `prefix` определяется как:  
  `prefix[i] = a[0] + a[1] + ... + a[i-1]`  
  где `prefix[0] = 0`, `prefix[1] = a[0]`, и т.д.
- **Сумма на отрезке** `[l, r]` (0-based):  
  `sum = prefix[r+1] - prefix[l]`

**Пример:**  
Для массива `a = [1, 2, 3, 4]` префиксный массив:  
`prefix = [0, 1, 3, 6, 10]`  
Сумма на отрезке `[1, 3]` (элементы 2, 3, 4):  
`prefix[4] - prefix[1] = 10 - 1 = 9`.

**Сложность:**
- Предподсчёт: O(n).
- Запрос: O(1).

---

#### **2. Двумерный случай (1b)**
**Задача:** Найти сумму элементов в прямоугольнике `[x1, y1] × [x2, y2]` за O(1).

**Метод:** Двумерные префиксные суммы.

**Теория:**
- **Префиксный массив** `prefix[i][j]` содержит сумму всех элементов от `(0, 0)` до `(i-1, j-1)`.
- **Формула построения:**  
  `prefix[i][j] = a[i-1][j-1] + prefix[i-1][j] + prefix[i][j-1] - prefix[i-1][j-1]`
- **Сумма в прямоугольнике** `[x1, y1] × [x2, y2]`:  
  `sum = prefix[x2][y2] - prefix[x1][y2] - prefix[x2][y1] + prefix[x1][y1]`

**Пример:**  
Для матрицы:
```
1 2  
3 4  
```
Префиксный массив:
```
0 0 0  
0 1 3  
0 4 10  
```
Сумма в прямоугольнике `[1,1] × [2,2]` (элементы 3 и 4):  
`prefix[2][2] - prefix[0][2] - prefix[2][0] + prefix[0][0] = 10 - 0 - 0 + 0 = 10`  
(Ошибка в предыдущем примере: правильная сумма 3+4=7. Исправление: формула должна использовать `x1-1` и `y1-1`.)

**Сложность:**
- Предподсчёт: O(n²).
- Запрос: O(1).

---

#### **3. Трёхмерный случай (1c)**
**Задача:** Найти сумму в параллелепипеде `[x1, y1, z1] × [x2, y2, z2]` за O(1).

**Метод:** Трёхмерные префиксные суммы.

**Теория:**
- **Префиксный массив** `prefix[i][j][k]` содержит сумму элементов от `(0,0,0)` до `(i-1,j-1,k-1)`.
- **Формула построения:**  
  `prefix[i][j][k] = a[i-1][j-1][k-1] + prefix[i-1][j][k] + prefix[i][j-1][k] + prefix[i][j][k-1] - prefix[i-1][j-1][k] - prefix[i-1][j][k-1] - prefix[i][j-1][k-1] + prefix[i-1][j-1][k-1]`
- **Сумма в параллелепипеде:**  
  `sum = prefix[x2][y2][z2] - prefix[x1][y2][z2] - prefix[x2][y1][z2] - prefix[x2][y2][z1] + prefix[x1][y1][z2] + prefix[x1][y2][z1] + prefix[x2][y1][z1] - prefix[x1][y1][z1]`

**Сложность:**
- Предподсчёт: O(n³).
- Запрос: O(1).

---

#### **4. M-мерный случай (1d)**
**Задача:** Найти сумму в m-мерном гиперпрямоугольнике.

**Метод:** Обобщённые префиксные суммы с принципом включения-исключения.

**Теория:**
- **Префиксный массив** `prefix` размерности `n^m` строится рекурсивно.
- **Формула суммы:** Для гиперпрямоугольника, заданного координатами `x1, x2, ..., xm` и `y1, y2, ..., ym`, сумма вычисляется как:  
  `sum = Σ (-1)^k * prefix[coords]`, где `k` — количество инверсий в координатах (чётность количества левых границ).
- **Реализация:** Используются битовые маски для перебора всех комбинаций левых/правых границ.

**Пример для 3D:**  
Сумма в параллелепипеде `[x1, y1, z1] × [x2, y2, z2]`:  
`sum = prefix[x2][y2][z2] - prefix[x1-1][y2][z2] - prefix[x2][y1-1][z2] - prefix[x2][y2][z1-1] + prefix[x1-1][y1-1][z2] + prefix[x1-1][y2][z1-1] + prefix[x2][y1-1][z1-1] - prefix[x1-1][y1-1][z1-1]`

**Сложность:**
- Предподсчёт: O(n^m).
- Запрос: O(2^m).

---

### **Общие принципы**
1. **Префиксные суммы** — ключевой инструмент для быстрого ответа на запросы суммы на подмножествах.
2. **Принцип включения-исключения** позволяет учитывать перекрытия областей в многомерных случаях.
3. **Рекурсия и битовые маски** упрощают обобщение на m измерений.

### **Пример кода для 2D**
```java
class RSQ2D {
    private int[][] prefix;
    public RSQ2D(int[][] a) {
        int n = a.length;
        prefix = new int[n+1][n+1];
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                prefix[i][j] = a[i-1][j-1] 
                    + prefix[i-1][j] 
                    + prefix[i][j-1] 
                    - prefix[i-1][j-1];
            }
        }
    }
    public int query(int x1, int y1, int x2, int y2) {
        return prefix[x2][y2] 
            - prefix[x1-1][y2] 
            - prefix[x2][y1-1] 
            + prefix[x1-1][y1-1];
    }
}
```

### **Заключение**
- Для **одномерного** случая достаточно простого префиксного массива.
- В **двумерном** и **трёхмерном** случаях используются обобщённые формулы с включением-исключением.
- Для **m-мерного** случая требуется рекурсивный подход или битовые маски для перебора всех комбинаций границ.