**Решение задачи 5:**

**Задача:** Найти суммарную длину объединения всех отрезков на прямой.

**Метод:** Сортировка и объединение интервалов.

---

### **Алгоритм**
1. **Сортировка отрезков:**  
   Отрезки сортируются по их начальной координате (`li`).

2. **Объединение интервалов:**
    - Инициализируем текущий объединённый отрезок как первый в отсортированном списке.
    - Для каждого последующего отрезка:
        - Если он пересекается с текущим объединённым отрезком (или касается его), объединяем их, расширяя конец до максимального значения.
        - Если он не пересекается, добавляем длину текущего объединённого отрезка к результату и начинаем новый объединённый отрезок.

3. **Финальное добавление:**  
   После обработки всех отрезков добавляем длину последнего объединённого отрезка к результату.

---

### **Пример кода**
```java
public static int sumUnion(int[] l, int[] r) {
    int n = l.length;
    if (n == 0) return 0;

    // Создаем и сортируем отрезки
    int[][] intervals = new int[n][2];
    for (int i = 0; i < n; i++) {
        intervals[i][0] = l[i];
        intervals[i][1] = r[i];
    }
    Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));

    int result = 0;
    int currentStart = intervals[0][0];
    int currentEnd = intervals[0][1];

    for (int i = 1; i < n; i++) {
        int nextStart = intervals[i][0];
        int nextEnd = intervals[i][1];

        if (nextStart <= currentEnd) {
            // Объединяем отрезки
            currentEnd = Math.max(currentEnd, nextEnd);
        } else {
            // Добавляем текущий объединенный отрезок
            result += currentEnd - currentStart;
            currentStart = nextStart;
            currentEnd = nextEnd;
        }
    }

    // Добавляем последний объединенный отрезок
    result += currentEnd - currentStart;
    return result;
}
```

---

### **Объяснение**
- **Сортировка:** Отрезки сортируются по началу, чтобы обрабатывать их в естественном порядке.
- **Объединение:** Если следующий отрезок начинается внутри текущего объединённого отрезка, они сливаются в один. Это гарантирует, что пересекающиеся отрезки учитываются как один непрерывный интервал.
- **Результат:** Суммируются длины всех объединённых отрезков, избегая двойного счета перекрывающихся областей.

---

### **Пример работы**
**Входные данные:**  
Отрезки `[1, 3]`, `[2, 4]`, `[5, 7]`.

**Обработка:**
1. Сортировка: `[1,3]`, `[2,4]`, `[5,7]`.
2. Объединение `[1,3]` и `[2,4]` → `[1,4]` (длина 3).
3. `[5,7]` не пересекается с `[1,4]`, добавляем 3 к результату.
4. Добавляем `[5,7]` (длина 2).  
   **Итог:** `3 + 2 = 5`.

---

### **Сложность**
- **Время:**
    - Сортировка: O(n log n).
    - Обход отрезков: O(n).  
      Итоговая сложность: **O(n log n)**.
- **Память:** O(n) для хранения отрезков.

---

### **Ключевые моменты**
- **Обработка пересечений:** Алгоритм корректно объединяет все пересекающиеся и касающиеся отрезки.
- **Оптимальность:** Сложность оптимальна для задачи.
- **Применимость:** Работает для произвольных отрезков, включая нулевую длину.