**Решение задачи 4:**

**Задача:** Найти точку на прямой, покрытую наибольшим количеством отрезков.

**Метод:** Событийная обработка (Sweep Line Algorithm).

---

### **Алгоритм**
1. **Создание событий:**  
   Каждый отрезок `[li, ri]` преобразуем в два события:
    - Начало отрезка в точке `li` (увеличивает счётчик активных отрезков на 1).
    - Конец отрезка в точке `ri` (уменьшает счётчик на 1).

2. **Сортировка событий:**
    - Сначала по координате.
    - При равных координатах: концы отрезков обрабатываются **до** начал. Это важно, чтобы точки, где заканчивается один отрезок и начинается другой, не считались пересекающимися.

3. **Обработка событий:**
    - Поддерживаем счётчик активных отрезков (`currentCount`).
    - Отслеживаем максимальное значение счётчика (`maxCount`) и соответствующую координату (`bestPoint`).

---

### **Пример кода**
```java
public static int findMaxCoveredPoint(int[] starts, int[] ends) {
    List<int[]> events = new ArrayList<>();
    for (int i = 0; i < starts.length; i++) {
        events.add(new int[]{starts[i], 1});   // Начало отрезка
        events.add(new int[]{ends[i], -1});    // Конец отрезка
    }

    // Сортировка: сначала по координате, при равенстве концы идут перед началами
    events.sort((a, b) -> {
        if (a[0] != b[0]) return Integer.compare(a[0], b[0]);
        return Integer.compare(b[1], a[1]); // Конец (-1) < начала (1)
    });

    int currentCount = 0;
    int maxCount = 0;
    int bestPoint = -1;

    for (int[] event : events) {
        currentCount += event[1]; // Обновляем счётчик
        if (currentCount > maxCount) {
            maxCount = currentCount;
            bestPoint = event[0]; // Запоминаем координату
        }
    }

    return bestPoint;
}
```

---

### **Объяснение**
- **События:** Каждое событие — это пара `(координата, тип)`. Тип `+1` для начала отрезка, `-1` для конца.
- **Сортировка:** Концы отрезков обрабатываются первыми, чтобы избежать ложных пересечений в граничных точках.
- **Счётчик:** При проходе по событиям счётчик увеличивается на начале отрезка и уменьшается на конце. Максимальное значение счётчика указывает на точку с наибольшим числом пересечений.

---

### **Пример работы**
**Входные данные:**  
Отрезки `[1, 3]`, `[2, 4]`, `[3, 5]`.

**События:**  
`(1, +1)`, `(2, +1)`, `(3, -1)`, `(3, +1)`, `(4, -1)`, `(5, -1)`.

**Обработка:**
1. `(1, +1)`: `currentCount = 1` → `maxCount = 1`, `bestPoint = 1`.
2. `(2, +1)`: `currentCount = 2` → `maxCount = 2`, `bestPoint = 2`.
3. `(3, -1)`: `currentCount = 1`.
4. `(3, +1)`: `currentCount = 2` → `maxCount` не обновляется.
5. Остальные события не меняют максимум.

**Результат:** Точка `2` (покрыта 2 отрезками).

---

### **Сложность**
- **Время:**
    - Создание событий: O(n).
    - Сортировка: O(n log n).
    - Обработка событий: O(n).  
      Итоговая сложность: **O(n log n)**.
- **Память:** O(n) для хранения событий.

---

### **Ключевые моменты**
- **Порядок обработки событий:** Концы отрезков обрабатываются до начал при одинаковых координатах.
- **Актуальность точки:** Возвращается первая точка, где достигается максимум. Если таких точек несколько, можно выбрать любую.
- **Применимость:** Алгоритм работает для произвольных отрезков (включая нулевую длину).