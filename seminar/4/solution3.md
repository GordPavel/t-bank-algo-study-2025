### **3. Определение наличия подотрезка с заданной суммой**

---

#### **(a) Массив содержит целые положительные числа**
**Метод:** Два указателя (Sliding Window).

**Идея:**  
Используем два указателя `left` и `right`, которые задают текущий подотрезок. Поскольку все элементы положительны, сумма монотонно растёт при движении `right` и убывает при движении `left`.

**Алгоритм:**
1. Инициализируем `left = 0`, `current_sum = 0`.
2. Двигаем `right` вправо, добавляя элементы в `current_sum`.
3. Если `current_sum` превысила целевую сумму, двигаем `left` вправо, вычитая элементы из `current_sum`.
4. Если `current_sum == target`, возвращаем `true`.

**Пример кода:**
```java
public static boolean hasSubarrayWithSumPositive(int[] a, int target) {
    int left = 0, currentSum = 0;
    for (int right = 0; right < a.length; right++) {
        currentSum += a[right];
        // Удаляем элементы слева, пока сумма больше target
        while (currentSum > target && left <= right) {
            currentSum -= a[left];
            left++;
        }
        if (currentSum == target) {
            return true;
        }
    }
    return false;
}
```

**Сложность:**
- Время: O(n), так как каждый элемент добавляется и удаляется из окна не более одного раза.

---

#### **(b) Массив содержит произвольные целые числа**
**Метод:** Хэш-таблица префиксных сумм.

**Идея:**  
Используем **префиксные суммы** и хэш-таблицу для хранения уже встреченных сумм. Если разность двух префиксных сумм равна `target`, то существует подотрезок с суммой `target`.

**Алгоритм:**
1. Вычисляем префиксные суммы `prefix[i] = a[0] + a[1] + ... + a[i-1]`.
2. Для каждой префиксной суммы `prefix[i]` проверяем, существует ли `prefix[j] = prefix[i] - target` для некоторого `j < i`.
3. Используем хэш-таблицу для хранения префиксных сумм, чтобы проверка выполнялась за O(1).

**Пример кода:**
```java
public static boolean hasSubarrayWithSumAny(int[] a, int target) {
    Set<Integer> prefixSums = new HashSet<>();
    int currentSum = 0;
    prefixSums.add(0); // Для случая, когда подотрезок начинается с индекса 0
    for (int num : a) {
        currentSum += num;
        if (prefixSums.contains(currentSum - target)) {
            return true;
        }
        prefixSums.add(currentSum);
    }
    return false;
}
```

**Объяснение:**
- Если `currentSum - target` уже есть в хэш-таблице, значит существует `j < i`, такой что `prefix[j] = currentSum - target`. Тогда сумма подотрезка `[j+1, i]` равна `target`.

**Сложность:**
- Время: O(n), так как каждая операция с хэш-таблицей выполняется за O(1).

---

### **Ключевые различия между случаями**
| Случай               | Метод               | Почему работает?                                                                 |
|----------------------|---------------------|---------------------------------------------------------------------------------|
| Положительные числа  | Два указателя       | Сумма монотонно растёт/убывает, что позволяет двигать указатели без пропусков.  |
| Произвольные числа   | Хэш-таблица         | Учитывает все возможные префиксные суммы, даже если сумма может "прыгать".      |

---

### **Примеры**
**Пример 1 (положительные числа):**  
Массив: `[1, 2, 3, 4]`, target = 6  
Ответ: `true` (подотрезок `[1, 2, 3]`).

**Пример 2 (отрицательные числа):**  
Массив: `[3, 4, -2, 1]`, target = 5  
Ответ: `true` (подотрезок `[3, 4, -2]`).

---

### **Заключение**
- Для **положительных чисел** используйте метод двух указателей (O(n)).
- Для **произвольных чисел** используйте хэш-таблицу префиксных сумм (O(n)).
- Оба решения работают за линейное время, но требуют разных подходов.