анаграмма = перестановка букв

Для решения задачи проверки, являются ли две подстроки $ S[l_1..r_1] $ и $ S[l_2..r_2] $ анаграммами за $ O(1) $ на запрос, мы будем использовать **подсчет частот символов** с предобработкой. Основная идея заключается в том, чтобы предварительно вычислить частоты символов для всех префиксов строки $ S $, а затем быстро сравнивать частоты символов для любых двух подстрок.

---

### **Логика решения:**

1. **Частоты символов**:
    - Для каждой позиции $ i $ в строке $ S $ вычислим массив частот символов для префикса $ S[0..i] $. Это позволит нам быстро находить частоты символов для любой подстроки $ S[l..r] $.

2. **Проверка на анаграмму**:
    - Две строки являются анаграммами, если они имеют одинаковый набор символов с одинаковыми частотами.
    - Для проверки анаграммы достаточно сравнить частоты символов для подстрок $ S[l_1..r_1] $ и $ S[l_2..r_2] $.

3. **Предобработка**:
    - Создадим массив `prefixFreq`, где `prefixFreq[i][c]` содержит количество вхождений символа $ c $ (где $ c \in [0, 25] $, соответствует буквам 'a'–'z') в префиксе $ S[0..i-1] $.
    - Для запроса $ [l, r] $ частоты символов подстроки можно вычислить как разность частот префиксов:
      $$
      \text{freq}[l..r][c] = \text{prefixFreq}[r+1][c] - \text{prefixFreq}[l][c]
      $$

4. **Сравнение частот**:
    - Для проверки анаграммы достаточно сравнить массивы частот для двух подстрок.

---

### **Реализация на Java:**

```java
import java.util.Scanner;

public class AnagramCheck {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String S = scanner.nextLine();
        int n = S.length();

        // Предвычисление частот символов для всех префиксов
        int[][] prefixFreq = new int[n + 1][26];

        for (int i = 1; i <= n; i++) {
            // Копируем частоты из предыдущего префикса
            for (int c = 0; c < 26; c++) {
                prefixFreq[i][c] = prefixFreq[i - 1][c];
            }
            // Увеличиваем частоту текущего символа
            prefixFreq[i][S.charAt(i - 1) - 'a']++;
        }

        // Функция для получения частот символов подстроки
        int[] getFrequencies(int l, int r) {
            int[] freq = new int[26];
            for (int c = 0; c < 26; c++) {
                freq[c] = prefixFreq[r + 1][c] - prefixFreq[l][c];
            }
            return freq;
        }

        // Запросы
        int q = scanner.nextInt();
        while (q-- > 0) {
            int l1 = scanner.nextInt() - 1; // Индексация с нуля
            int r1 = scanner.nextInt() - 1; // Индексация с нуля
            int l2 = scanner.nextInt() - 1; // Индексация с нуля
            int r2 = scanner.nextInt() - 1; // Индексация с нуля

            // Получаем частоты символов для обеих подстрок
            int[] freq1 = getFrequencies(l1, r1);
            int[] freq2 = getFrequencies(l2, r2);

            // Проверяем, совпадают ли частоты
            boolean areAnagrams = true;
            for (int c = 0; c < 26; c++) {
                if (freq1[c] != freq2[c]) {
                    areAnagrams = false;
                    break;
                }
            }

            System.out.println(areAnagrams ? "YES" : "NO");
        }
    }
}
```

---

### **Объяснение кода:**

1. **Предобработка частот**:
    - Мы создаем массив `prefixFreq`, где `prefixFreq[i][c]` содержит количество вхождений символа $ c $ в префиксе $ S[0..i-1] $.
    - Для каждого символа строки $ S $ обновляем соответствующую частоту.

2. **Функция `getFrequencies`**:
    - Эта функция вычисляет частоты символов для подстроки $ S[l..r] $ за $ O(1) $, используя формулу:
      $$
      \text{freq}[l..r][c] = \text{prefixFreq}[r+1][c] - \text{prefixFreq}[l][c]
      $$

3. **Запросы**:
    - Для каждого запроса $ [l_1, r_1] $ и $ [l_2, r_2] $ вычисляем частоты символов для обеих подстрок.
    - Сравниваем массивы частот. Если все частоты совпадают, то подстроки являются анаграммами.

---

### **Пример работы программы:**

#### Ввод:
```text
S = "abacaba"
q = 3
Запросы:
1 3 4 6
0 2 3 5
2 4 4 6
```

#### Выполнение:
1. Для запроса $ [1, 3] $ и $ [4, 6] $ ($ S[1..3] = "bac", S[4..6] = "cab" $):
    - Частоты символов:
        - $ S[1..3]: [1, 1, 1, 0, ..., 0] $
        - $ S[4..6]: [1, 1, 1, 0, ..., 0] $
    - Частоты совпадают. Ответ: "YES".

2. Для запроса $ [0, 2] $ и $ [3, 5] $ ($ S[0..2] = "aba", S[3..5] = "aca" $):
    - Частоты символов:
        - $ S[0..2]: [2, 1, 0, 0, ..., 0] $
        - $ S[3..5]: [1, 0, 2, 0, ..., 0] $
    - Частоты не совпадают. Ответ: "NO".

3. Для запроса $ [2, 4] $ и $ [4, 6] $ ($ S[2..4] = "aca", S[4..6] = "cab" $):
    - Частоты символов:
        - $ S[2..4]: [1, 0, 2, 0, ..., 0] $
        - $ S[4..6]: [1, 1, 1, 0, ..., 0] $
    - Частоты не совпадают. Ответ: "NO".

#### Вывод:
```text
YES
NO
NO
```

---

### **Сложность алгоритма:**

1. **Предобработка**:
    - Вычисление частот символов для всех префиксов: $ O(n \cdot k) $, где $ k = 26 $ (количество символов в алфавите).

2. **Ответ на запрос**:
    - Проверка анаграммы: $ O(k) $, где $ k = 26 $.

3. **Общая сложность**:
    - Предобработка: $ O(n \cdot k) $.
    - Ответы на $ q $ запросов: $ O(q \cdot k) $.

---

### **Заключение:**
Используя предобработку частот символов, мы можем проверять, являются ли две подстроки анаграммами, за $ O(1) $ на запрос после линейной предобработки. Этот подход эффективен для большого количества запросов.