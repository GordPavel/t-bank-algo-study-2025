Реализуем алгоритм Кнута-Морриса-Пратта (КМП) для поиска всех вхождений строки $ S $ в строку $ T $. Этот алгоритм работает за $ O(|T| + |S|) $, что значительно эффективнее наивного подхода.

---

### **Логика решения:**

1. **Основная идея**:
   - КМП использует предобработку строки $ S $ для создания так называемого "префикс-функции" (или массива "π").
   - Префикс-функция $ \pi[i] $ для позиции $ i $ в строке $ S $ определяет длину наибольшего префикса строки $ S[0..i] $, который также является суффиксом этой подстроки.
   - Используя префикс-функцию, мы можем избежать лишних сравнений символов при поиске $ S $ в $ T $.

2. **Шаги алгоритма**:
   - **Предобработка**: Вычисляем префикс-функцию для строки $ S $.
   - **Поиск**: Проходим по строке $ T $ и используем префикс-функцию для быстрого сопоставления символов.

3. **Преимущества**:
   - Алгоритм не требует обратного хода при несовпадении символов, что делает его линейным по времени.
   - Временная сложность: $ O(|T| + |S|) $.

4. **Пример работы префикс-функции**:
   Для строки $ S = "ababc" $:
   - $ \pi[0] = 0 $ (пустой префикс).
   - $ \pi[1] = 0 $ (нет совпадения между префиксом и суффиксом).
   - $ \pi[2] = 1 $ ($ "a" $ — префикс и суффикс для $ "aba" $).
   - $ \pi[3] = 2 $ ($ "ab" $ — префикс и суффикс для $ "abab" $).
   - $ \pi[4] = 0 $ (нет совпадения для $ "ababc" $).

---

### **Реализация на Java:**

```java
import java.util.ArrayList;
import java.util.List;

public class KMPAlgorithm {
    // Метод для вычисления префикс-функции
    public static int[] computePrefixFunction(String S) {
        int n = S.length();
        int[] pi = new int[n];
        pi[0] = 0; // Префикс-функция для первого символа всегда 0

        for (int i = 1; i < n; i++) {
            int j = pi[i - 1]; // Значение префикс-функции для предыдущего символа

            // Пока символы не совпадают и j > 0, уменьшаем j
            while (j > 0 && S.charAt(i) != S.charAt(j)) {
                j = pi[j - 1];
            }

            // Если символы совпали, увеличиваем j
            if (S.charAt(i) == S.charAt(j)) {
                j++;
            }

            pi[i] = j; // Сохраняем значение префикс-функции
        }

        return pi;
    }

    // Метод для поиска всех вхождений S в T с использованием КМП
    public static List<Integer> findAllOccurrences(String T, String S) {
        List<Integer> result = new ArrayList<>();
        int n = T.length();
        int m = S.length();

        // Если S пустая или длиннее T, возвращаем пустой результат
        if (m == 0 || m > n) {
            return result;
        }

        // Вычисляем префикс-функцию для S
        int[] pi = computePrefixFunction(S);

        int j = 0; // Текущая позиция в S
        for (int i = 0; i < n; i++) {
            // Пока символы не совпадают и j > 0, уменьшаем j
            while (j > 0 && T.charAt(i) != S.charAt(j)) {
                j = pi[j - 1];
            }

            // Если символы совпали, увеличиваем j
            if (T.charAt(i) == S.charAt(j)) {
                j++;
            }

            // Если достигли конца S, значит, нашли вхождение
            if (j == m) {
                result.add(i - m + 1); // Добавляем начальную позицию вхождения
                j = pi[j - 1]; // Продолжаем поиск следующих вхождений
            }
        }

        return result;
    }

    public static void main(String[] args) {
        // Пример использования
        String T = "abracadabra";
        String S = "abra";

        List<Integer> occurrences = findAllOccurrences(T, S);

        System.out.println("Позиции вхождений строки S в строку T:");
        for (int pos : occurrences) {
            System.out.println(pos);
        }
    }
}
```

---

### **Объяснение кода:**

1. **Вычисление префикс-функции**:
   - Массив `pi` хранит значения префикс-функции для каждой позиции в строке $ S $.
   - Мы используем переменную $ j $, которая указывает текущую длину совпадающего префикса/суффикса.
   - Если символы не совпадают, мы "откатываемся" к предыдущему значению префикс-функции.

2. **Поиск вхождений**:
   - Перебираем символы строки $ T $.
   - Если символы $ T[i] $ и $ S[j] $ совпадают, увеличиваем $ j $.
   - Если $ j $ достигает длины $ S $, значит, найдено вхождение. Добавляем начальную позицию в результат.
   - После нахождения вхождения "откатываемся" к предыдущему значению префикс-функции для поиска следующих вхождений.

3. **Пример работы**:
   - Для $ T = "abracadabra" $ и $ S = "abra" $:
      - Префикс-функция для $ S = "abra" $: $ [0, 0, 0, 1] $.
      - Поиск в $ T $ находит вхождения на позициях $ 0 $ и $ 7 $.

---

### **Сложность алгоритма:**

1. **Временная сложность**:
   - Предобработка (вычисление префикс-функции): $ O(|S|) $.
   - Поиск вхождений: $ O(|T|) $.
   - Общая сложность: $ O(|T| + |S|) $.

2. **Пространственная сложность**:
   - Используется дополнительная память для массива префикс-функции ($ O(|S|) $).
   - Результат хранится в списке ($ O(k) $, где $ k $ — количество вхождений).

---

### **Пример работы программы:**

#### Ввод:
```text
T = "abracadabra"
S = "abra"
```

#### Выполнение:
1. Префикс-функция для $ S = "abra" $: $ [0, 0, 0, 1] $.
2. Поиск в $ T $:
   - Найдено вхождение на позиции $ 0 $.
   - Найдено вхождение на позиции $ 7 $.

#### Вывод:
```text
Позиции вхождений строки S в строку T:
0
7
```

---

### **Заключение:**
