Для нахождения наибольшей общей подстроки (Longest Common Substring, LCS) двух строк $ S_1 $ и $ S_2 $ за $ O(n \log n) $, мы будем использовать **суффиксный массив** и **LCP-массив**. Этот подход эффективен, так как позволяет находить общие подстроки за логарифмическое время.

---

### **Логика решения:**

1. **Суффиксный массив**:
    - Суффиксный массив — это упорядоченный список всех суффиксов строки.
    - Если мы объединим строки $ S_1 $ и $ S_2 $ через уникальный разделитель (например, `#`), то общие подстроки будут соответствовать соседним суффиксам в суффиксном массиве, принадлежащим разным строкам.

2. **LCP-массив**:
    - LCP-массив (Longest Common Prefix) хранит длины наибольших общих префиксов между соседними суффиксами в суффиксном массиве.
    - Максимальное значение в LCP-массиве для суффиксов, принадлежащих разным строкам, будет длиной наибольшей общей подстроки.

3. **Алгоритм**:
    - Объединяем строки $ S_1 $ и $ S_2 $ через разделитель: $ S = S_1 + "\#" + S_2 $.
    - Строим суффиксный массив и LCP-массив для строки $ S $.
    - Находим максимальное значение в LCP-массиве для пар суффиксов, где один суффикс принадлежит $ S_1 $, а другой — $ S_2 $.

4. **Сложность**:
    - Построение суффиксного массива и LCP-массива: $ O(n \log n) $.
    - Поиск максимального значения в LCP-массиве: $ O(n) $.
    - Общая сложность: $ O(n \log n) $.

---

### **Реализация на Java:**

```java
import java.util.*;

public class LongestCommonSubstring {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Ввод строк S1 и S2
        String S1 = scanner.nextLine();
        String S2 = scanner.nextLine();

        // Объединяем строки через разделитель
        String S = S1 + "#" + S2;
        int n = S.length();
        int len1 = S1.length();

        // Строим суффиксный массив
        int[] suffixArray = buildSuffixArray(S);

        // Строим LCP-массив
        int[] lcp = buildLCPArray(S, suffixArray);

        // Находим максимальную общую подстроку
        int maxLCP = 0;
        int startIndex = -1;

        for (int i = 1; i < n; i++) {
            // Проверяем, что суффиксы принадлежат разным строкам
            boolean inS1 = suffixArray[i] < len1;
            boolean inS2 = suffixArray[i - 1] >= len1 + 1;

            if ((inS1 && inS2) || (!inS1 && !inS2)) {
                if (lcp[i] > maxLCP) {
                    maxLCP = lcp[i];
                    startIndex = suffixArray[i];
                }
            }
        }

        // Вывод результата
        if (maxLCP > 0) {
            System.out.println("Наибольшая общая подстрока: " + S.substring(startIndex, startIndex + maxLCP));
            System.out.println("Длина: " + maxLCP);
        } else {
            System.out.println("Общих подстрок нет.");
        }
    }

    // Построение суффиксного массива
    private static int[] buildSuffixArray(String S) {
        int n = S.length();
        Integer[] suffixes = new Integer[n];
        for (int i = 0; i < n; i++) {
            suffixes[i] = i;
        }

        // Сортируем суффиксы лексикографически
        Arrays.sort(suffixes, (a, b) -> {
            return S.substring(a).compareTo(S.substring(b));
        });

        // Преобразуем в примитивный массив
        int[] suffixArray = new int[n];
        for (int i = 0; i < n; i++) {
            suffixArray[i] = suffixes[i];
        }
        return suffixArray;
    }

    // Построение LCP-массива
    private static int[] buildLCPArray(String S, int[] suffixArray) {
        int n = S.length();
        int[] lcp = new int[n];
        int[] rank = new int[n];

        // Вычисляем ранги суффиксов
        for (int i = 0; i < n; i++) {
            rank[suffixArray[i]] = i;
        }

        int h = 0;
        for (int i = 0; i < n; i++) {
            if (rank[i] > 0) {
                int j = suffixArray[rank[i] - 1];
                while (i + h < n && j + h < n && S.charAt(i + h) == S.charAt(j + h)) {
                    h++;
                }
                lcp[rank[i]] = h;
                if (h > 0) {
                    h--;
                }
            }
        }

        return lcp;
    }
}
```

---

### **Объяснение кода:**

1. **Объединение строк**:
    - Мы объединяем строки $ S_1 $ и $ S_2 $ через разделитель `#`, чтобы различать суффиксы из разных строк.

2. **Построение суффиксного массива**:
    - Суффиксный массив строится путем сортировки всех суффиксов строки $ S $ лексикографически.

3. **Построение LCP-массива**:
    - Для каждого суффикса вычисляем длину наибольшего общего префикса с предыдущим суффиксом в суффиксном массиве.

4. **Поиск наибольшей общей подстроки**:
    - Перебираем LCP-массив и находим максимальное значение для пар суффиксов, принадлежащих разным строкам.

5. **Вывод результата**:
    - Выводим наибольшую общую подстроку и её длину.

---

### **Пример работы программы:**

#### Ввод:
```text
S1 = "abcdef"
S2 = "zbcdfg"
```

#### Выполнение:
1. Объединяем строки: $ S = "abcdef#zbcdfg" $.
2. Строим суффиксный массив:
   ```
   [6 (#), 0 (abcdef#...), 7 (bcdfg), 1 (bcdef#...), 8 (cdfg), 2 (cdef#...), ...]
   ```
3. Строим LCP-массив:
   ```
   [0, 0, 3, 0, 2, 0, ...]
   ```
4. Находим максимальное значение LCP для пар суффиксов из разных строк: $ \text{maxLCP} = 3 $.
5. Наибольшая общая подстрока: $ "bcd" $.

#### Вывод:
```text
Наибольшая общая подстрока: bcd
Длина: 3
```

---

### **Сложность алгоритма:**

1. **Построение суффиксного массива**:
    - Сортировка суффиксов: $ O(n \log n) $.

2. **Построение LCP-массива**:
    - Вычисление LCP: $ O(n) $.

3. **Поиск максимального значения**:
    - Перебор LCP-массива: $ O(n) $.

4. **Общая сложность**:
    - $ O(n \log n) $.

---

### **Заключение:**
Используя суффиксный массив и LCP-массив, мы можем найти наибольшую общую подстроку двух строк за $ O(n \log n) $. Этот подход эффективен и хорошо масштабируется для больших строк.