Давайте решим задачу поиска всех вхождений строки $ S $ в строку $ T $. Мы будем использовать наивный алгоритм, который работает за $ O(|T| \cdot |S|) $.

---

### **Логика решения:**

1. **Наивный подход**:
    - Для каждой позиции $ i $ в строке $ T $ проверяем, совпадает ли подстрока $ T[i..i+|S|-1] $ со строкой $ S $.
    - Если совпадение найдено, добавляем позицию $ i $ в список результатов.

2. **Ограничения**:
    - Временная сложность: $ O(|T| \cdot |S|) $.
    - Пространственная сложность: $ O(1) $ (не считая хранение результата).

3. **Почему это работает?**
    - Мы перебираем все возможные начальные позиции $ i $ в строке $ T $, где может начинаться подстрока длины $ |S| $.
    - Для каждой позиции $ i $ проверяем символы $ T[i+j] $ и $ S[j] $ для всех $ j $ от $ 0 $ до $ |S|-1 $.
    - Если все символы совпадают, значит, подстрока $ S $ встречается в позиции $ i $.

4. **Крайние случаи**:
    - Если $ |S| > |T| $, то $ S $ не может быть подстрокой $ T $, и результат будет пустым.
    - Если $ S $ — пустая строка, то результат зависит от интерпретации задачи (обычно считается, что она встречается в каждой позиции).

---

### **Реализация на Java:**

```java
import java.util.ArrayList;
import java.util.List;

public class SubstringSearch {
    public static List<Integer> findAllOccurrences(String T, String S) {
        List<Integer> result = new ArrayList<>();
        int n = T.length();
        int m = S.length();

        // Если S длиннее T, то вхождений нет
        if (m == 0 || m > n) {
            return result;
        }

        // Перебираем все возможные начальные позиции i
        for (int i = 0; i <= n - m; i++) {
            boolean match = true;

            // Проверяем совпадение символов T[i..i+m-1] и S[0..m-1]
            for (int j = 0; j < m; j++) {
                if (T.charAt(i + j) != S.charAt(j)) {
                    match = false;
                    break;
                }
            }

            // Если совпадение найдено, добавляем позицию i в результат
            if (match) {
                result.add(i);
            }
        }

        return result;
    }

    public static void main(String[] args) {
        // Пример использования
        String T = "abracadabra";
        String S = "abra";

        List<Integer> occurrences = findAllOccurrences(T, S);

        System.out.println("Позиции вхождений строки S в строку T:");
        for (int pos : occurrences) {
            System.out.println(pos);
        }
    }
}
```

---

### **Объяснение кода:**

1. **Входные данные**:
    - $ T $ — основная строка.
    - $ S $ — подстрока, которую нужно найти.

2. **Основной цикл**:
    - Цикл `for (int i = 0; i <= n - m; i++)` перебирает все возможные начальные позиции $ i $ в строке $ T $, где может начинаться подстрока длины $ |S| $.
    - Условие `i <= n - m` гарантирует, что мы не выйдем за границы строки $ T $.

3. **Проверка совпадения**:
    - Вложенный цикл `for (int j = 0; j < m; j++)` проверяет, совпадают ли символы $ T[i+j] $ и $ S[j] $ для всех $ j $ от $ 0 $ до $ m-1 $.
    - Если хотя бы один символ не совпадает, устанавливаем флаг `match = false` и прерываем проверку.

4. **Добавление результата**:
    - Если все символы совпали (`match == true`), добавляем позицию $ i $ в список результатов.

5. **Выходные данные**:
    - Возвращаем список позиций, где начинаются вхождения подстроки $ S $ в строку $ T $.

---

### **Пример работы программы:**

#### Ввод:
```text
T = "abracadabra"
S = "abra"
```

#### Выполнение:
1. Проверяем позицию $ i = 0 $: подстрока $ T[0..3] = "abra" $ совпадает с $ S $. Добавляем $ 0 $ в результат.
2. Проверяем позицию $ i = 1 $: подстрока $ T[1..4] = "brac" $ не совпадает с $ S $.
3. Проверяем позицию $ i = 2 $: подстрока $ T[2..5] = "racd" $ не совпадает с $ S $.
4. Проверяем позицию $ i = 7 $: подстрока $ T[7..10] = "abra" $ совпадает с $ S $. Добавляем $ 7 $ в результат.

#### Вывод:
```text
Позиции вхождений строки S в строку T:
0
7
```

---

### **Сложность алгоритма:**

1. **Временная сложность**:
    - Внешний цикл выполняется $ O(|T| - |S| + 1) $ раз.
    - Внутренний цикл выполняется $ O(|S|) $ раз для каждой итерации внешнего цикла.
    - Общая сложность: $ O(|T| \cdot |S|) $.

2. **Пространственная сложность**:
    - Используется дополнительная память для хранения списка результатов ($ O(k) $, где $ k $ — количество вхождений).

---

### **Улучшения:**
Если требуется более эффективное решение, можно использовать алгоритмы:
- Алгоритм Кнута-Морриса-Пратта (КМП) ($ O(|T| + |S|) $).
- Алгоритм Рабина-Карпа (хеширование) ($ O(|T| + |S|) $ в среднем).

Если вам нужна реализация этих алгоритмов, дайте знать!