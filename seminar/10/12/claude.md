Решение: Распространение заразы во взвешенном графе
Введение
В этой задаче нам дан взвешенный граф, где некоторые вершины изначально заражены. Зараза распространяется от зараженных
вершин к незараженным через ребра, причем время распространения равно весу ребра. Нам нужно определить, в какой момент
времени каждая вершина будет заражена.

Эта задача является классической задачей поиска кратчайших путей от множества источников. Мы можем рассматривать
изначально зараженные вершины как источники, а веса ребер как время распространения заразы. Время заражения вершины
будет равно минимальному времени, за которое зараза может достичь этой вершины от любого из источников.

Для решения этой задачи мы можем использовать алгоритм Дейкстры, модифицированный для работы с несколькими источниками.

Алгоритм решения
Создадим приоритетную очередь для хранения пар (вершина, время заражения).
Добавим в очередь все изначально зараженные вершины с временем заражения 0.
Пока очередь не пуста:
Извлечем вершину с минимальным временем заражения.
Для каждого соседа этой вершины:
Вычислим новое время заражения как (время заражения текущей вершины + вес ребра).
Если новое время меньше текущего времени заражения соседа, обновим время и добавим соседа в очередь.
В результате для каждой вершины мы получим минимальное время, за которое она будет заражена.
Реализация на Java

```java
import java.util.*;

public class InfectionSpread {

    // Класс для представления ребра графа
    static class Edge {
        int to;     // Конечная вершина
        int weight; // Вес ребра (время распространения заразы)

        public Edge(int to, int weight) {
            this.to = to;
            this.weight = weight;
        }
    }

    // Класс для хранения пары (вершина, время заражения) в приоритетной очереди
    static class Node implements Comparable<Node> {
        int vertex;   // Вершина
        int time;     // Время заражения

        public Node(int vertex, int time) {
            this.vertex = vertex;
            this.time = time;
        }

        @Override
        public int compareTo(Node other) {
            return Integer.compare(this.time, other.time);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Считываем количество вершин и ребер
        int n = scanner.nextInt(); // Количество вершин
        int m = scanner.nextInt(); // Количество ребер

        // Создаем список смежности для представления графа
        List<List<Edge>> graph = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<>());
        }

        // Считываем ребра
        for (int i = 0; i < m; i++) {
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            int weight = scanner.nextInt();

            // Добавляем ребра в обоих направлениях (для неориентированного графа)
            graph.get(u).add(new Edge(v, weight));
            graph.get(v).add(new Edge(u, weight));
        }

        // Считываем количество изначально зараженных вершин
        int k = scanner.nextInt();

        // Считываем изначально зараженные вершины
        Set<Integer> initiallyInfected = new HashSet<>();
        for (int i = 0; i < k; i++) {
            initiallyInfected.add(scanner.nextInt());
        }

        // Находим время заражения для каждой вершины
        int[] infectionTimes = findInfectionTimes(graph, initiallyInfected, n);

        // Выводим результат
        for (int i = 1; i <= n; i++) {
            if (infectionTimes[i] == Integer.MAX_VALUE) {
                System.out.println("Вершина " + i + " не будет заражена");
            } else {
                System.out.println("Вершина " + i + " будет заражена через " + infectionTimes[i] + " единиц времени");
            }
        }
    }

    /**
     * Находит время заражения для каждой вершины
     *
     * @param graph список смежности графа
     * @param initiallyInfected множество изначально зараженных вершин
     * @param n количество вершин
     * @return массив времен заражения для каждой вершины
     */
    public static int[] findInfectionTimes(List<List<Edge>> graph, Set<Integer> initiallyInfected, int n) {
        // Массив для хранения времен заражения
        int[] infectionTimes = new int[n + 1];
        Arrays.fill(infectionTimes, Integer.MAX_VALUE);

        // Массив для отслеживания посещенных вершин
        boolean[] visited = new boolean[n + 1];

        // Приоритетная очередь для выбора вершины с минимальным временем заражения
        PriorityQueue<Node> pq = new PriorityQueue<>();

        // Добавляем изначально зараженные вершины в очередь
        for (int vertex : initiallyInfected) {
            infectionTimes[vertex] = 0;
            pq.add(new Node(vertex, 0));
        }

        // Алгоритм Дейкстры для нахождения минимального времени заражения
        while (!pq.isEmpty()) {
            Node current = pq.poll();
            int u = current.vertex;

            // Если вершина уже обработана, пропускаем её
            if (visited[u]) {
                continue;
            }

            // Отмечаем вершину как посещенную
            visited[u] = true;

            // Перебираем всех соседей текущей вершины
            for (Edge edge : graph.get(u)) {
                int v = edge.to;
                int weight = edge.weight;

                // Если найдено меньшее время заражения для соседа
                if (!visited[v] && infectionTimes[u] + weight < infectionTimes[v]) {
                    infectionTimes[v] = infectionTimes[u] + weight;
                    pq.add(new Node(v, infectionTimes[v]));
                }
            }
        }

        return infectionTimes;
    }
}
```

Подробное объяснение
Структуры данных
Edge - класс для представления ребра графа:

to - конечная вершина ребра
weight - вес ребра (время распространения заразы)
Node - класс для хранения пары (вершина, время заражения) в приоритетной очереди:

vertex - номер вершины
time - время заражения вершины
Реализует интерфейс Comparable для сортировки по времени заражения
Представление графа:

Используем список смежности для представления графа
graph.get(u) содержит список всех ребер, исходящих из вершины u
Алгоритм Дейкстры с несколькими источниками
Алгоритм Дейкстры обычно используется для нахождения кратчайших путей от одного источника до всех остальных вершин. В
нашем случае у нас несколько источников (изначально зараженные вершины), но алгоритм легко модифицируется для работы с
несколькими источниками:

Инициализация:

Создаем массив infectionTimes[] для хранения времен заражения и инициализируем его бесконечностями
Создаем массив visited[] для отслеживания посещенных вершин
Создаем приоритетную очередь pq для выбора вершины с минимальным временем заражения
Для каждой изначально зараженной вершины устанавливаем время заражения 0 и добавляем её в очередь
Основной цикл:

Пока очередь не пуста:
Извлекаем вершину u с минимальным временем заражения из очереди
Если вершина уже обработана, пропускаем её
Отмечаем вершину как посещенную
Для каждого соседа v вершины u:
Вычисляем новое время заражения как (время заражения u + вес ребра)
Если новое время меньше текущего времени заражения v, обновляем время и добавляем v в очередь
Результат:

Массив infectionTimes[] содержит минимальное время заражения для каждой вершины
Если infectionTimes[v] = Integer.MAX_VALUE, то вершина v недостижима из изначально зараженных вершин (не будет заражена)
Пример работы алгоритма
Рассмотрим граф с 5 вершинами и 6 ребрами:

    1 --- 2

/ \     \
/ \     \
5 --- 4 --- 3
Веса ребер:

(1, 2): 5
(1, 4): 3
(1, 5): 7
(2, 3): 2
(3, 4): 1
(4, 5): 4
Изначально заражена вершина 1.

Инициализация:

infectionTimes = [0, 0, ∞, ∞, ∞, ∞]
visited = [false, false, false, false, false, false]
pq = [(1, 0)]
Итерация 1:

Извлекаем (1, 0) из pq
Отмечаем вершину 1 как посещенную
Обрабатываем соседей вершины 1:
Вершина 2: infectionTimes[2] = 0 + 5 = 5, добавляем (2, 5) в pq
Вершина 4: infectionTimes[4] = 0 + 3 = 3, добавляем (4, 3) в pq
Вершина 5: infectionTimes[5] = 0 + 7 = 7, добавляем (5, 7) в pq
infectionTimes = [0, 0, 5, ∞, 3, 7]
pq = [(4, 3), (2, 5), (5, 7)]
Итерация 2:

Извлекаем (4, 3) из pq
Отмечаем вершину 4 как посещенную
Обрабатываем соседей вершины 4:
Вершина 3: infectionTimes[3] = 3 + 1 = 4, добавляем (3, 4) в pq
Вершина 5: infectionTimes[5] = 3 + 4 = 7, но это не меньше текущего значения 7, не обновляем
infectionTimes = [0, 0, 5, 4, 3, 7]
pq = [(3, 4), (2, 5), (5, 7)]
Итерация 3:

Извлекаем (3, 4) из pq
Отмечаем вершину 3 как посещенную
Обрабатываем соседей вершины 3:
Вершина 2: infectionTimes[2] = 4 + 2 = 6, но это не меньше текущего значения 5, не обновляем
infectionTimes = [0, 0, 5, 4, 3, 7]
pq = [(2, 5), (5, 7)]
Итерация 4:

Извлекаем (2, 5) из pq
Отмечаем вершину 2 как посещенную
Обрабатываем соседей вершины 2:
Вершина 3: уже посещена, пропускаем
infectionTimes = [0, 0, 5, 4, 3, 7]
pq = [(5, 7)]
Итерация 5:

Извлекаем (5, 7) из pq
Отмечаем вершину 5 как посещенную
Обрабатываем соседей вершины 5:
Вершина 4: уже посещена, пропускаем
infectionTimes = [0, 0, 5, 4, 3, 7]
pq = []
Результат:

Вершина 1: заражена изначально (время 0)
Вершина 2: будет заражена через 5 единиц времени
Вершина 3: будет заражена через 4 единицы времени
Вершина 4: будет заражена через 3 единицы времени
Вершина 5: будет заражена через 7 единиц времени
Случай с несколькими изначально зараженными вершинами
Если изначально заражено несколько вершин, алгоритм работает аналогично, но мы добавляем все изначально зараженные
вершины в приоритетную очередь с временем заражения 0. Это позволяет нам найти минимальное время заражения для каждой
вершины от любого из источников.

Например, если в нашем примере изначально заражены вершины 1 и 3, то:

Вершина 1: заражена изначально (время 0)
Вершина 2: будет заражена через 2 единицы времени (от вершины 3)
Вершина 3: заражена изначально (время 0)
Вершина 4: будет заражена через 1 единицу времени (от вершины 3)
Вершина 5: будет заражена через 5 единиц времени (от вершины 4)
Сложность алгоритма
Временная сложность: O((V + E) log V), где V - количество вершин, E - количество ребер

Каждая вершина извлекается из приоритетной очереди не более одного раза: O(V log V)
Каждое ребро обрабатывается не более одного раза: O(E log V)
Общая сложность: O((V + E) log V)
Пространственная сложность: O(V + E)

O(V) для хранения массивов infectionTimes[] и visited[]
O(E) для хранения графа в виде списка смежности
O(V) для хранения приоритетной очереди в худшем случае
Оптимизации и вариации
Ранняя остановка:

Если нас интересует время заражения только для определенной вершины, мы можем остановить алгоритм, как только эта
вершина будет обработана.
Обработка недостижимых вершин:

Если после завершения алгоритма infectionTimes[v] = Integer.MAX_VALUE, то вершина v недостижима из изначально зараженных
вершин (не будет заражена).
В зависимости от требований задачи, мы можем вывести "Не будет заражена" или другое специальное значение.
Учет времени иммунитета:

Если в задаче есть дополнительное условие, что вершина становится иммунной через определенное время после заражения, мы
можем модифицировать алгоритм, добавив дополнительную проверку.
Заключение
Алгоритм Дейкстры с несколькими источниками является эффективным решением для задачи о распространении заразы во
взвешенном графе. Он позволяет найти минимальное время заражения для каждой вершины от любого из изначально зараженных
источников.

Ключевые моменты решения:

Использование приоритетной очереди для эффективного выбора вершины с минимальным временем заражения
Добавление всех изначально зараженных вершин в очередь с временем заражения 0
Обновление времени заражения соседей при нахождении более короткого пути
Обработка недостижимых вершин (которые не будут заражены)
Этот алгоритм может быть легко адаптирован для различных вариаций задачи, таких как учет времени иммунитета, различные
скорости распространения заразы и т.д.