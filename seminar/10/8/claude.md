Решение: Поиск отрезка с максимальным значением произведения (сумма × минимум)

Введение

В этой задаче нам нужно найти отрезок массива, для которого произведение суммы элементов на минимальный элемент отрезка максимально.

Формально, для массива a[1...n] нам нужно найти такие индексы l и r (1 ≤ l ≤ r ≤ n), что значение
(a[l] + a[l+1] + ... + a[r]) × min(a[l], a[l+1], ..., a[r]) максимально.

Подход к решению

Для решения этой задачи мы можем использовать подход, основанный на фиксации минимального элемента отрезка. Для каждого возможного минимального значения мы найдем максимальный отрезок, содержащий только элементы не меньше этого значения.

Алгоритм будет следующим:
Для каждого уникального значения в массиве (потенциального минимума отрезка):
Найдем все максимальные отрезки, где все элементы не меньше этого значения
Для каждого такого отрезка вычислим произведение (сумма × минимум)
Обновим ответ, если найдено большее значение

Для эффективной реализации этого подхода мы можем использовать стек для нахождения максимальных отрезков с элементами не меньше заданного значения.

Реализация на Java

import java.util.*;

public class MaxProductSubarray {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Считываем размер массива
        int n = scanner.nextInt();
        
        // Считываем элементы массива
        int[] a = new int[n];
        for (int i = 0; i  valueIndexPairs = new ArrayList();
        for (int i = 0; i  Integer.compare(p1[0], p2[0]));
        
        // Массив для хранения префиксных сумм
        long[] prefixSum = new long[n + 1];
        for (int i = 0; i  0 && a[left - 1] >= value) {
                left--;
                processed[left] = true;
            }
            
            // Расширяем отрезок вправо
            while (right = value) {
                right++;
                processed[right] = true;
            }
            
            // Вычисляем сумму элементов отрезка
            long sum = prefixSum[right + 1] - prefixSum[left];
            
            // Вычисляем произведение (сумма × минимум)
            long product = sum * value;
            
            // Обновляем ответ, если найдено большее значение
            if (product > maxProduct) {
                maxProduct = product;
                bestLeft = left;
                bestRight = right;
            }
        }
        
        return new Result(maxProduct, bestLeft, bestRight);
    }
}

Оптимизированное решение

Предыдущее решение имеет сложность O(n log n) из-за сортировки. Мы можем оптимизировать его до O(n), используя подход с монотонным стеком. Вот оптимизированная версия:

import java.util.*;

public class MaxProductSubarrayOptimized {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Считываем размер массива
        int n = scanner.nextInt();
        
        // Считываем элементы массива
        int[] a = new int[n];
        for (int i = 0; i  stack = new Stack();
        
        // Находим ближайший меньший элемент слева
        for (int i = 0; i = a[i]) {
                stack.pop();
            }
            if (!stack.isEmpty()) {
                leftSmaller[i] = stack.peek();
            }
            stack.push(i);
        }
        
        // Очищаем стек для повторного использования
        stack.clear();
        
        // Находим ближайший меньший элемент справа
        for (int i = n - 1; i >= 0; i--) {
            while (!stack.isEmpty() && a[stack.peek()] >= a[i]) {
                stack.pop();
            }
            if (!stack.isEmpty()) {
                rightSmaller[i] = stack.peek();
            }
            stack.push(i);
        }
        
        long maxProduct = 0;
        int bestLeft = 0;
        int bestRight = 0;
        
        // Для каждого элемента как потенциального минимума отрезка
        for (int i = 0; i  maxProduct) {
                maxProduct = product;
                bestLeft = left;
                bestRight = right;
            }
        }
        
        return new Result(maxProduct, bestLeft, bestRight);
    }
}

Подробное объяснение

Подход с сортировкой

В первом решении мы используем следующий подход:

Сортировка элементов по значению:
Создаем список пар (значение, индекс) и сортируем его по значению в порядке возрастания
Это позволяет нам рассматривать потенциальные минимумы отрезков в порядке возрастания

Префиксные суммы:
Вычисляем префиксные суммы массива для быстрого вычисления суммы любого отрезка
Сумма элементов отрезка [l, r] равна prefixSum[r+1] - prefixSum[l]

Обработка элементов:
Для каждого уникального значения в порядке возрастания:
Находим максимальный отрезок, содержащий только элементы не меньше этого значения
Вычисляем произведение (сумма × минимум) для этого отрезка
Обновляем ответ, если найдено большее значение

Отслеживание обработанных элементов:
Используем массив processed для отслеживания, какие элементы уже обработаны
Это позволяет избежать повторной обработки одинаковых значений

Подход с монотонным стеком

Во втором, оптимизированном решении мы используем монотонный стек для нахождения ближайших меньших элементов:

Префиксные суммы:
Аналогично первому решению, вычисляем префиксные суммы для быстрого вычисления суммы отрезка

Нахождение ближайших меньших элементов:
Для каждого элемента a[i] находим ближайший меньший элемент слева (leftSmaller[i])
Для каждого элемента a[i] находим ближайший меньший элемент справа (rightSmaller[i])
Используем монотонный стек для эффективного нахождения этих элементов

Вычисление максимального произведения:
Для каждого элемента a[i] как потенциального минимума отрезка:
Определяем границы максимального отрезка, где a[i] - минимум:
Левая граница: leftSmaller[i] + 1
Правая граница: rightSmaller[i] - 1
Вычисляем сумму элементов отрезка
Вычисляем произведение (сумма × минимум)
Обновляем ответ, если найдено большее значение

Монотонный стек

Монотонный стек - это стек, элементы которого поддерживаются в порядке возрастания или убывания. В нашем случае мы используем монотонно возрастающий стек для нахождения ближайших меньших элементов:

Нахождение ближайшего меньшего элемента слева:
Перебираем элементы массива слева направо
Для каждого элемента a[i]:
Удаляем из стека все элементы, значения которых не меньше a[i]
Если стек не пуст, верхний элемент стека - ближайший меньший элемент слева
Добавляем индекс i в стек

Нахождение ближайшего меньшего элемента справа:
Перебираем элементы массива справа налево
Для каждого элемента a[i]:
Удаляем из стека все элементы, значения которых не меньше a[i]
Если стек не пуст, верхний элемент стека - ближайший меньший элемент справа
Добавляем индекс i в стек

Пример работы алгоритма

Рассмотрим массив [3, 1, 6, 4, 5, 2]:

Префиксные суммы:
prefixSum = [0, 3, 4, 10, 14, 19, 21]

Нахождение ближайших меньших элементов:
leftSmaller = [-1, -1, 1, 1, 3, 1]
rightSmaller = [1, 6, 5, 5, 5, 6]

Вычисление максимального произведения:
Для a[0] = 3:
Отрезок: [0, 0]
Сумма: 3
Произведение: 3 * 3 = 9
Для a[1] = 1:
Отрезок: [1, 5]
Сумма: 18
Произведение: 18 * 1 = 18
Для a[2] = 6:
Отрезок: [2, 2]
Сумма: 6
Произведение: 6 * 6 = 36
Для a[3] = 4:
Отрезок: [2, 4]
Сумма: 15
Произведение: 15 * 4 = 60
Для a[4] = 5:
Отрезок: [4, 4]
Сумма: 5
Произведение: 5 * 5 = 25
Для a[5] = 2:
Отрезок: [2, 4]
Сумма: 15
Произведение: 15 * 2 = 30

Ответ:
Максимальное произведение: 60
Отрезок: [2, 4] (индексы 2, 3, 4, значения 6, 4, 5)

Сложность алгоритма

Первое решение (с сортировкой):
Временная сложность: O(n log n) из-за сортировки
Пространственная сложность: O(n) для хранения массивов

Второе решение (с монотонным стеком):
Временная сложность: O(n)
Пространственная сложность: O(n) для хранения массивов и стека

Заключение

Мы рассмотрели два подхода к решению задачи о поиске отрезка с максимальным значением произведения (сумма × минимум):

Подход с сортировкой элементов по значению и последовательной обработкой потенциальных минимумов
Оптимизированный подход с использованием монотонного стека для нахождения ближайших меньших элементов

Оба подхода корректно решают задачу, но второй подход более эффективен с точки зрения временной сложности (O(n) против O(n log n)).

Ключевая идея обоих решений заключается в том, что для каждого потенциального минимума отрезка мы находим максимальный отрезок, где этот элемент является минимальным, и вычисляем произведение (сумма × минимум) для этого отрезка.