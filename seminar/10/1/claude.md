Решение: Добавление операций getMin(x), getMax(x), getSize(x) в СНМ

Введение

Система непересекающихся множеств (СНМ, или DSU - Disjoint Set Union) - это структура данных, которая поддерживает операции объединения множеств и проверки принадлежности элементов одному множеству. Нам нужно расширить эту структуру, добавив операции:
getMin(x) - получение минимального элемента в множестве, содержащем x
getMax(x) - получение максимального элемента в множестве, содержащем x
getSize(x) - получение размера множества, содержащего x

Реализация на Java

public class DisjointSetUnion {
private int[] parent;  // Массив родителей
private int[] rank;    // Ранг для оптимизации объединения
private int[] size;    // Размер каждого множества
private int[] min;     // Минимальный элемент в множестве
private int[] max;     // Максимальный элемент в множестве

    /**
     Инициализация СНМ с n элементами
     */
    public DisjointSetUnion(int n) {
        parent = new int[n];
        rank = new int[n];
        size = new int[n];
        min = new int[n];
        max = new int[n];
        
        // Изначально каждый элемент находится в своем собственном множестве
        for (int i = 0; i < n; i++) {
            parent[i] = i;      // Каждый элемент - корень своего множества
            rank[i] = 0;        // Начальный ранг - 0
            size[i] = 1;        // Размер каждого множества - 1
            min[i] = i;         // Минимум - сам элемент
            max[i] = i;         // Максимум - сам элемент
        }
    }
    
    /**
     Находит корень множества, содержащего элемент x
     с применением сжатия путей
     */
    public int find(int x) {
        if (parent[x] != x) {
            parent[x] = find(parent[x]);  // Сжатие путей
        }
        return parent[x];
    }
    
    /**
     Объединяет множества, содержащие элементы x и y
     */
    public void union(int x, int y) {
        int rootX = find(x);
        int rootY = find(y);
        
        // Если элементы уже в одном множестве, ничего не делаем
        if (rootX == rootY) {
            return;
        }
        
        // Объединяем по рангу (меньший ранг присоединяем к большему)
        if (rank[rootX] < rank[rootY]) {
            // rootX становится потомком rootY
            parent[rootX] = rootY;
            
            // Обновляем информацию о множестве rootY
            size[rootY] += size[rootX];
            min[rootY] = Math.min(min[rootY], min[rootX]);
            max[rootY] = Math.max(max[rootY], max[rootX]);
        } else {
            // rootY становится потомком rootX
            parent[rootY] = rootX;
            
            // Обновляем информацию о множестве rootX
            size[rootX] += size[rootY];
            min[rootX] = Math.min(min[rootX], min[rootY]);
            max[rootX] = Math.max(max[rootX], max[rootY]);
            
            // Если ранги равны, увеличиваем ранг rootX
            if (rank[rootX] == rank[rootY]) {
                rank[rootX]++;
            }
        }
    }
    
    /**
     Возвращает минимальный элемент в множестве, содержащем x
     */
    public int getMin(int x) {
        int root = find(x);
        return min[root];
    }
    
    /**
     Возвращает максимальный элемент в множестве, содержащем x
     */
    public int getMax(int x) {
        int root = find(x);
        return max[root];
    }
    
    /**
     Возвращает размер множества, содержащем x
     */
    public int getSize(int x) {
        int root = find(x);
        return size[root];
    }
}

Объяснение решения

Структура данных:
parent[] - хранит родителя каждого элемента
rank[] - хранит ранг (приблизительную высоту) каждого поддерева для оптимизации объединения
size[] - хранит размер каждого множества
min[] - хранит минимальный элемент в каждом множестве
max[] - хранит максимальный элемент в каждом множестве

Инициализация:
Каждый элемент изначально находится в своем собственном множестве
Размер каждого множества равен 1
Минимум и максимум равны самому элементу

Операция find(x):
Находит корень множества, содержащего элемент x
Использует оптимизацию "сжатие путей" для ускорения последующих операций

Операция union(x, y):
Объединяет множества, содержащие элементы x и y
Использует эвристику "объединение по рангу" для минимизации высоты дерева
При объединении обновляет информацию о размере, минимуме и максимуме результирующего множества

Новые операции:
getMin(x) - находит корень множества и возвращает минимальный элемент
getMax(x) - находит корень множества и возвращает максимальный элемент
getSize(x) - находит корень множества и возвращает его размер

Сложность операций

find(x) - амортизированная O(α(n)), где α(n) - обратная функция Аккермана (практически константа)
union(x, y) - амортизированная O(α(n))
getMin(x), getMax(x), getSize(x) - амортизированная O(α(n)), так как включают вызов find(x)

Таким образом, все операции имеют практически константную сложность.