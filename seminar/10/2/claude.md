Решение: Поиск размера самой большой компоненты связности в динамическом графе

Введение

В этой задаче нам нужно отслеживать размер самой большой компоненты связности в графе, который постепенно строится путем добавления рёбер. Для эффективного решения этой задачи идеально подходит структура данных "Система непересекающихся множеств" (СНМ, или DSU - Disjoint Set Union).

Алгоритм решения

Инициализируем СНМ, где каждая вершина находится в своей собственной компоненте связности.
При добавлении ребра (u, v):
Если u и v уже находятся в одной компоненте, ничего не меняется.
Если u и v в разных компонентах, объединяем их и обновляем размер самой большой компоненты.
После каждого добавления ребра выводим размер самой большой компоненты.

Реализация на Java

import java.util.*;

public class LargestComponentTracker {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Считываем количество вершин и рёбер
        int n = scanner.nextInt(); // Количество вершин
        int m = scanner.nextInt(); // Количество рёбер
        
        // Создаем объект для отслеживания компонент связности
        ComponentTracker tracker = new ComponentTracker(n);
        
        // Добавляем рёбра по одному и выводим размер самой большой компоненты
        for (int i = 0; i < m; i++) {
            int u = scanner.nextInt() - 1; // Вычитаем 1, если вершины нумеруются с 1
            int v = scanner.nextInt() - 1;
            
            tracker.addEdge(u, v);
            System.out.println(tracker.getLargestComponentSize());
        }
    }
    
    static class ComponentTracker {
        private int[] parent; // Массив родителей для СНМ
        private int[] size;   // Размер каждой компоненты
        private int maxSize;  // Размер самой большой компоненты
        
        /**
         Инициализация трекера компонент для графа с n вершинами
         */
        public ComponentTracker(int n) {
            parent = new int[n];
            size = new int[n];
            maxSize = 1; // Изначально самая большая компонента имеет размер 1
            
            // Каждая вершина изначально в своей компоненте
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                size[i] = 1;
            }
        }
        
        /**
         Находит корень (представителя) компоненты, содержащей вершину x
         */
        private int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]); // Сжатие путей
            }
            return parent[x];
        }
        
        /**
         Добавляет ребро между вершинами u и v
         */
        public void addEdge(int u, int v) {
            int rootU = find(u);
            int rootV = find(v);
            
            // Если вершины уже в одной компоненте, ничего не делаем
            if (rootU == rootV) {
                return;
            }
            
            // Объединяем компоненты (меньшую присоединяем к большей)
            if (size[rootU] < size[rootV]) {
                parent[rootU] = rootV;
                size[rootV] += size[rootU];
                maxSize = Math.max(maxSize, size[rootV]);
            } else {
                parent[rootV] = rootU;
                size[rootU] += size[rootV];
                maxSize = Math.max(maxSize, size[rootU]);
            }
        }
        
        /**
         Возвращает размер самой большой компоненты связности
         */
        public int getLargestComponentSize() {
            return maxSize;
        }
    }
}

Подробное объяснение

Структура данных

СНМ (Система непересекающихся множеств):
parent[] - хранит родителя каждой вершины
size[] - хранит размер компоненты, корнем которой является данная вершина
maxSize - хранит размер самой большой компоненты

Основные операции

find(x) - находит корень компоненты, содержащей вершину x:
Использует оптимизацию "сжатие путей" для ускорения последующих операций
Амортизированная сложность: O(α(n)), где α(n) - обратная функция Аккермана (практически константа)

addEdge(u, v) - добавляет ребро между вершинами u и v:
Находит корни компонент, содержащих u и v
Если вершины уже в одной компоненте, ничего не делает
Иначе объединяет компоненты, присоединяя меньшую к большей (эвристика "объединение по размеру")
Обновляет размер результирующей компоненты и максимальный размер
Сложность: O(α(n))

getLargestComponentSize() - возвращает размер самой большой компоненты:
Просто возвращает значение переменной maxSize
Сложность: O(1)

Процесс работы алгоритма

Инициализация:
Создаем n компонент, каждая содержит одну вершину
Размер каждой компоненты равен 1
Максимальный размер компоненты равен 1

Добавление ребра (u, v):
Если u и v уже в одной компоненте, ничего не меняется
Если u и v в разных компонентах:
Объединяем компоненты
Обновляем размер объединенной компоненты
Обновляем максимальный размер компоненты

Вывод результата:
После каждого добавления ребра выводим текущий максимальный размер компоненты

Оптимизации

Сжатие путей - при поиске корня компоненты все вершины на пути переподключаются напрямую к корню, что ускоряет последующие операции.

Объединение по размеру - при объединении компонент меньшая присоединяется к большей, что минимизирует высоту дерева и ускоряет операции поиска.

Сложность алгоритма

Временная сложность: O(m × α(n)), где m - количество рёбер, n - количество вершин, α(n) - обратная функция Аккермана (практически константа).
Пространственная сложность: O(n) для хранения массивов parent и size.

Этот алгоритм эффективно решает поставленную задачу, позволяя отслеживать размер самой большой компоненты связности в динамически изменяющемся графе.