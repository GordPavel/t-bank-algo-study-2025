Для решения задачи, где требуется обрабатывать запросы на покраску вершин дерева в белый цвет и поиск ближайшего черного предка, используется простой подход с последовательным обходом предков. Решение основано на структуре данных, где для каждой вершины хранится информация о её родителе и цвете. При запросе поиска ближайшего черного предка последовательно проверяются все предки текущей вершины, начиная с неё самой.

---

### Подход

1. **Представление дерева**:
    - Дерево задано как массив `parent[]`, где `parent[i]` — индекс родителя вершины `i`.
    - Корень дерева имеет `parent[0] = -1`.

2. **Цвет вершин**:
    - Все вершины изначально черные (`color[i] = true`).
    - При запросе `paint x` вершина `x` окрашивается в белый цвет (`color[x] = false`).

3. **Поиск ближайшего черного предка**:
    - Для заданной вершины `x` проверяется цвет самой вершины.
    - Если цвет черный, возвращается `x`.
    - Если цвет белый, проверяются родители вершины, начиная с ближайшего (`parent[x]`), до корня дерева.
    - Если ни один предок не является черным, возвращается `-1`.

4. **Сложность**:
    - Операция `paint` выполняется за `O(1)`.
    - Операция `query` выполняется за `O(h)`, где `h` — высота дерева.
    - В худшем случае (`h = n`) сложность запроса `query` равна `O(n)`.

---

### Реализация на Java

```java
import java.util.Scanner;

public class ClosestBlackAncestor {
    private static int[] parent;
    private static boolean[] color;

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Чтение количества вершин
        int n = scanner.nextInt();
        parent = new int[n];
        color = new boolean[n];

        // Инициализация цвета всех вершин как черного
        for (int i = 0; i < n; i++) {
            color[i] = true;
        }

        // Чтение родителей для каждой вершины
        for (int i = 0; i < n; i++) {
            int p = scanner.nextInt();
            parent[i] = p; // parent[i] = -1 для корня
        }

        // Чтение количества запросов
        int q = scanner.nextInt();

        // Обработка запросов
        for (int i = 0; i < q; i++) {
            String queryType = scanner.next();
            int x = scanner.nextInt();

            if (queryType.equals("paint")) {
                // Покраска вершины в белый цвет
                color[x] = false;
            } else if (queryType.equals("query")) {
                // Поиск ближайшего черного предка
                int result = findClosestBlackAncestor(x);
                System.out.println(result);
            }
        }
    }

    private static int findClosestBlackAncestor(int x) {
        int current = x;
        while (current != -1) {
            if (color[current]) {
                return current;
            }
            current = parent[current]; // Переход к родителю
        }
        return -1; // Не найдено
    }
}
```

---

### Объяснение

1. **Чтение данных**:
    - Сначала считывается количество вершин `n`.
    - Затем для каждой вершины `i` (от `0` до `n-1`) считывается индекс её родителя. Корень дерева имеет `parent[0] = -1`.

2. **Инициализация**:
    - Массив `color` инициализируется как `true` для всех вершин, так как изначально все вершины черные.

3. **Обработка запросов**:
    - Если запрос типа `paint x`, цвет вершины `x` устанавливается в `false`.
    - Если запрос типа `query x`, вызывается метод `findClosestBlackAncestor(x)`, который последовательно проверяет цвет текущей вершины и всех её предков.

4. **Метод `findClosestBlackAncestor(int x)`**:
    - Начинает проверку с самой вершины `x`.
    - Если цвет вершины черный, возвращается её индекс.
    - Если цвет белый, переходит к родителю (`parent[x]`) и продолжает проверку.
    - Если все проверенные вершины белые, возвращается `-1`.

---

### Пример работы

#### Вход:
```
5
-1 0 0 1 1
3
query 4
paint 4
query 4
paint 1
query 4
```

#### Выход:
```
4
1
0
```

#### Объяснение:
1. Дерево имеет следующую структуру:
    - Корень `0`.
    - Вершины `1` и `2` — дети корня.
    - Вершины `3` и `4` — дети вершины `1`.

2. Запрос `query 4`: вершина `4` черная → возвращается `4`.
3. Запрос `paint 4`: вершина `4` окрашена в белый цвет.
4. Запрос `query 4`: вершина `4` белая, её родитель `1` черный → возвращается `1`.
5. Запрос `paint 1`: вершина `1` окрашена в белый цвет.
6. Запрос `query 4`: вершина `4` белая, её родитель `1` белый, родитель `0` черный → возвращается `0`.

---

### Заключение

Реализация решения основана на последовательном обходе предков для поиска ближайшего черного. Подход прост в реализации и подходит для задач с небольшими ограничениями на размер дерева и количество запросов. Для больших деревьев и частых запросов может потребоваться более оптимизированный подход, например, с использованием структур данных, поддерживающих быстрый поиск. Однако для большинства случаев данный алгоритм эффективен и легко читаем.