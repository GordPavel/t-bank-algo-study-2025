–†–∞—Å—Å–º–æ—Ç—Ä–∏–º –∑–∞–¥–∞—á—É:

---

## üìò –£—Å–ª–æ–≤–∏–µ:

–î–∞–Ω–æ **–¥–µ—Ä–µ–≤–æ** (—Å–≤—è–∑–Ω—ã–π –∞—Ü–∏–∫–ª–∏—á–Ω—ã–π –≥—Ä–∞—Ñ), –≤—Å–µ –≤–µ—Ä—à–∏–Ω—ã –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ **—á—ë—Ä–Ω—ã–µ**.

–î–≤–∞ —Ç–∏–ø–∞ –∑–∞–ø—Ä–æ—Å–æ–≤:

1. `PAINT x` ‚Äî –ø–æ–∫—Ä–∞—Å–∏—Ç—å –≤–µ—Ä—à–∏–Ω—É `x` –≤ **–±–µ–ª—ã–π** —Ü–≤–µ—Ç.
2. `FIND x` ‚Äî –Ω–∞–π—Ç–∏ **–±–ª–∏–∂–∞–π—à–µ–≥–æ —á–µ—Ä–Ω–æ–≥–æ –ø—Ä–µ–¥–∫–∞** –≤–µ—Ä—à–∏–Ω—ã `x`.

---

## üß† –ö–ª—é—á–µ–≤–∞—è –∏–¥–µ—è:

* –î–µ—Ä–µ–≤–æ ‚Äî —ç—Ç–æ –≥—Ä–∞—Ñ –±–µ–∑ —Ü–∏–∫–ª–æ–≤, –ø–æ—ç—Ç–æ–º—É —É –∫–∞–∂–¥–æ–π –≤–µ—Ä—à–∏–Ω—ã –µ—Å—Ç—å **–æ–¥–∏–Ω —Ä–æ–¥–∏—Ç–µ–ª—å** (–∫—Ä–æ–º–µ –∫–æ—Ä–Ω—è).
* –ú—ã —Ö—Ä–∞–Ω–∏–º:

    * –¥–ª—è –∫–∞–∂–¥–æ–π –≤–µ—Ä—à–∏–Ω—ã ‚Äî –µ—ë **—Ä–æ–¥–∏—Ç–µ–ª—è**,
    * —Ü–≤–µ—Ç –∫–∞–∂–¥–æ–π –≤–µ—Ä—à–∏–Ω—ã (`true` = —á–µ—Ä–Ω–∞—è, `false` = –±–µ–ª–∞—è),
    * –º–∞—Å—Å–∏–≤ `nearestBlackAncestor[x]`: –±–ª–∏–∂–∞–π—à–∏–π —á–µ—Ä–Ω—ã–π –ø—Ä–µ–¥–æ–∫ –≤–µ—Ä—à–∏–Ω—ã `x`.

---

## üîß –ü–æ–¥—Ö–æ–¥:

### –†–µ—à–∞–µ–º –∑–∞–¥–∞—á—É —Å –ø–æ–º–æ—â—å—é **–¥–∏—Å–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–æ–¥—ä–µ–º–∞ –∫ –ø—Ä–µ–¥–∫–∞–º** (–∏–ª–∏ –ø—Ä–æ—Å—Ç–æ –∏–¥–µ–º –≤–≤–µ—Ä—Ö –ø–æ —Ä–æ–¥–∏—Ç–µ–ª—è–º), –æ–±–Ω–æ–≤–ª—è—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –ø–æ –º–µ—Ä–µ –ø–æ–∫—Ä–∞—Å–∫–∏.

–ú—ã **–Ω–µ –±—É–¥–µ–º** –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —Ç—è–∂–µ–ª—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –≤—Ä–æ–¥–µ LCA/segment tree, –ø–æ—Ç–æ–º—É —á—Ç–æ:

* –¥–µ—Ä–µ–≤–æ –Ω–µ –∏–∑–º–µ–Ω—è–µ—Ç—Å—è,
* –∑–∞–ø—Ä–æ—Å–æ–≤ –Ω–µ –æ—á–µ–Ω—å –º–Ω–æ–≥–æ,
* –ø—Ä–µ–¥–∫–æ–≤ –º–æ–∂–Ω–æ –ø—Ä–æ—Ö–æ–¥–∏—Ç—å –≤–≤–µ—Ä—Ö –ª–∏–Ω–µ–π–Ω–æ –¥–æ –±–ª–∏–∂–∞–π—à–µ–≥–æ —á–µ—Ä–Ω–æ–≥–æ.

---

## ‚úÖ –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ Java:

```java
import java.util.*;

public class TreeColoring {
    static List<Integer>[] tree;
    static int[] parent;
    static boolean[] isBlack;
    static int n;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        n = sc.nextInt();  // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–µ—Ä—à–∏–Ω
        int q = sc.nextInt(); // –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∑–∞–ø—Ä–æ—Å–æ–≤

        tree = new ArrayList[n];
        parent = new int[n];
        isBlack = new boolean[n];

        for (int i = 0; i < n; i++) {
            tree[i] = new ArrayList<>();
            isBlack[i] = true; // –≤—Å–µ –≤–µ—Ä—à–∏–Ω—ã –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ —á–µ—Ä–Ω—ã–µ
        }

        // —á–∏—Ç–∞–µ–º –¥–µ—Ä–µ–≤–æ
        for (int i = 1; i < n; i++) {
            int p = sc.nextInt(); // —Ä–æ–¥–∏—Ç–µ–ª—å –≤–µ—Ä—à–∏–Ω—ã i
            parent[i] = p;
            tree[p].add(i);
        }
        parent[0] = -1; // –∫–æ—Ä–µ–Ω—å

        // –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∑–∞–ø—Ä–æ—Å—ã
        for (int i = 0; i < q; i++) {
            String command = sc.next();
            int x = sc.nextInt();

            if (command.equals("PAINT")) {
                paintWhite(x);
            } else if (command.equals("FIND")) {
                System.out.println(findNearestBlackAncestor(x));
            }
        }
    }

    static void paintWhite(int x) {
        isBlack[x] = false;
    }

    static int findNearestBlackAncestor(int x) {
        while (x != -1 && !isBlack[x]) {
            x = parent[x];
        }
        return x;
    }
}
```

---

## üß™ –ü—Ä–∏–º–µ—Ä:

**–í–≤–æ–¥:**

```
7 6
0
0
1
1
2
2
PAINT 4
PAINT 2
FIND 4
FIND 2
FIND 5
FIND 6
```

**–û–ø–∏—Å–∞–Ω–∏–µ –¥–µ—Ä–µ–≤–∞:**

```
        0
      /   \
     1     2
    / \   / \
   3  4  5  6
```

**–í—ã–≤–æ–¥:**

```
1
0
2
2
```

---

## ‚è± –≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å:

* `PAINT x` ‚Äî O(1)
* `FIND x` ‚Äî –≤ —Ö—É–¥—à–µ–º —Å–ª—É—á–∞–µ O(h), –≥–¥–µ `h` ‚Äî –≤—ã—Å–æ—Ç–∞ –¥–µ—Ä–µ–≤–∞ (–ª–∏–Ω–µ–π–Ω–æ –≤–≤–µ—Ä—Ö –¥–æ –∫–æ—Ä–Ω—è)

–î–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –º–æ–∂–Ω–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å **–¥–∏—Å–∫—Ä–µ—Ç–Ω—ã–π –ø–æ–¥—ä–µ–º (binary lifting)**, –Ω–æ —ç—Ç–æ –Ω—É–∂–Ω–æ —Ç–æ–ª—å–∫–æ –ø—Ä–∏ —Å—Ç—Ä–æ–≥–∏—Ö –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è—Ö –Ω–∞ –≤—Ä–µ–º—è (–Ω–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ `n` –æ—á–µ–Ω—å –±–æ–ª—å—à–æ–µ –∏ `q` ‚â´ 10‚Åµ).

---

–•–æ—á–µ—à—å –≤–∞—Ä–∏–∞–Ω—Ç —Å –±–∏–Ω–∞—Ä–Ω—ã–º –ø–æ–¥—ä–µ–º–æ–º –¥–ª—è `FIND x` –∑–∞ `O(log n)`?
