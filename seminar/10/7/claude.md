Решение: Поиск ближайшего черного предка в дереве с динамической перекраской

Введение

В этой задаче нам дано дерево, где изначально все вершины покрашены в черный цвет. Нам нужно обрабатывать два типа запросов:
Покрасить заданную вершину в белый цвет
Найти ближайшего черного предка для заданной вершины

Для эффективного решения этой задачи мы можем использовать структуру данных, которая позволяет быстро находить ближайшего черного предка. Одним из подходов является использование метода двоичного подъема (binary lifting).

Алгоритм решения

Предварительно вычислим для каждой вершины её предков на расстояниях 2^0, 2^1, 2^2, ..., 2^k, где 2^k ≤ n (n - количество вершин в дереве).
Будем хранить информацию о цвете каждой вершины.
При запросе на поиск ближайшего черного предка будем использовать двоичный подъем для эффективного перемещения по дереву.

Реализация на Java

import java.util.*;

public class NearestBlackAncestor {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Считываем количество вершин и запросов
        int n = scanner.nextInt(); // Количество вершин
        int q = scanner.nextInt(); // Количество запросов
        
        // Считываем структуру дерева (родитель для каждой вершины)
        int[] parent = new int[n + 1];
        for (int i = 2; i  queue = new LinkedList();
            queue.add(1);
            
            while (!queue.isEmpty()) {
                int v = queue.poll();
                
                // Перебираем всех детей вершины v
                for (int i = 2; i = 0; j--) {
                int ancestor = upvertex;
                
                // Если предок на расстоянии 2^j белый, поднимаемся к нему
                if (isWhite[ancestor]) {
                    vertex = ancestor;
                }
            }
            
            // Поднимаемся на один шаг вверх (к ближайшему черному предку)
            int nearestBlackAncestor = upvertex;
            
            // Если мы дошли до корня и он белый, возвращаем -1 (нет черных предков)
            if (isWhite[nearestBlackAncestor] && nearestBlackAncestor == 1) {
                return -1;
            }
            
            return nearestBlackAncestor;
        }
    }
}

Подробное объяснение

Структура данных

TreeAncestorFinder:
n - количество вершин в дереве
logN - логарифм от n по основанию 2 (максимальная высота двоичного подъема)
up - матрица для двоичного подъема, где upv - это 2^j-й предок вершины v
isWhite[] - булев массив, отслеживающий цвет вершин (true - белый, false - черный)
depth[] - глубина каждой вершины в дереве
parent[] - родитель каждой вершины

Основные операции

calculateDepth() - вычисляет глубину каждой вершины в дереве:
Использует BFS для обхода дерева от корня
Для каждой вершины устанавливает глубину на 1 больше, чем у её родителя
Сложность: O(n)

precomputeAncestors() - предварительно вычисляет предков для всех вершин:
Заполняет матрицу up, где upv - это 2^j-й предок вершины v
Сначала заполняет первый уровень (непосредственные родители)
Затем использует динамическое программирование для заполнения остальных уровней
Сложность: O(n log n)

paintWhite(vertex) - покрасить вершину в белый цвет:
Устанавливает isWhite[vertex] = true
Сложность: O(1)

findNearestBlackAncestor(vertex) - находит ближайшего черного предка для заданной вершины:
Если сама вершина черная, возвращает её
Иначе использует двоичный подъем для поиска ближайшего черного предка
Сложность: O(log n)

Процесс работы алгоритма

Инициализация:
Считываем структуру дерева (родитель для каждой вершины)
Вычисляем глубину каждой вершины
Предварительно вычисляем предков для всех вершин
Изначально все вершины черные (isWhite[] = false)

Обработка запросов:
Запрос 1 (покрасить вершину в белый цвет):
Устанавливаем isWhite[vertex] = true
Запрос 2 (найти ближайшего черного предка):
Если сама вершина черная, возвращаем её
Иначе используем двоичный подъем для поиска ближайшего черного предка

Двоичный подъем для поиска ближайшего черного предка

Ключевая идея алгоритма - использование двоичного подъема для эффективного поиска ближайшего черного предка. Вместо того чтобы подниматься по одному шагу, мы используем предварительно вычисленную таблицу up, чтобы делать "прыжки" размером 2^j.

Алгоритм поиска ближайшего черного предка:
Если сама вершина черная, возвращаем её.
Иначе используем двоичный подъем:
Начинаем с самого большого возможного "прыжка" (2^logN).
Если предок на расстоянии 2^j белый, поднимаемся к нему.
Уменьшаем j и повторяем, пока не дойдем до j=0.
После этого мы находимся в вершине, у которой непосредственный предок (upvertex) является ближайшим черным предком.
Если мы дошли до корня и он белый, возвращаем -1 (нет черных предков).

Пример работы алгоритма

Рассмотрим дерево с 5 вершинами:
1
/ \
2   3
/ \
4   5

Изначально все вершины черные.

Запрос: paintWhite(2)
isWhite[2] = true
Дерево: 1(черный), 2(белый), 3(черный), 4(черный), 5(черный)

Запрос: findNearestBlackAncestor(4)
Вершина 4 черная, возвращаем 4

Запрос: findNearestBlackAncestor(2)
Вершина 2 белая
Используем двоичный подъем
Ближайший черный предок - 1
Возвращаем 1

Запрос: paintWhite(1)
isWhite[1] = true
Дерево: 1(белый), 2(белый), 3(черный), 4(черный), 5(черный)

Запрос: findNearestBlackAncestor(2)
Вершина 2 белая
Используем двоичный подъем
Предок - 1, но он тоже белый и является корнем
Возвращаем -1 (нет черных предков)

Сложность алгоритма

Временная сложность:
Инициализация: O(n log n) для предварительного вычисления предков
Запрос на покраску: O(1)
Запрос на поиск ближайшего черного предка: O(log n)
Для q запросов: O(n log n + q log n)

Пространственная сложность: O(n log n) для хранения матрицы up и других массивов.

Заключение

Данное решение эффективно обрабатывает оба типа запросов, используя метод двоичного подъема для быстрого поиска ближайшего черного предка. Предварительное вычисление предков позволяет выполнять запросы на поиск за O(log n) времени, что делает решение эффективным даже для больших деревьев и большого количества запросов.

Ключевая идея решения заключается в использовании двоичного подъема для эффективного перемещения по дереву и поиска ближайшего черного предка.