Решение: Подсчет непрерывных отрезков из единиц в динамическом массиве

Введение

В этой задаче нам нужно реализовать структуру данных для работы с массивом, изначально заполненным нулями, которая поддерживает два типа операций:
Установить значение элемента массива a[i] в 1
Найти количество непрерывных отрезков из единиц в массиве

Для эффективного решения этой задачи мы можем использовать Систему Непересекающихся Множеств (СНМ, или DSU - Disjoint Set Union), которая позволит нам отслеживать и объединять непрерывные отрезки из единиц.

Реализация на Java

import java.util.*;

public class ContinuousSegmentsCounter {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Считываем размер массива и количество запросов
        int n = scanner.nextInt(); // Размер массива
        int q = scanner.nextInt(); // Количество запросов
        
        // Создаем структуру данных для работы с массивом
        SegmentTracker tracker = new SegmentTracker(n);
        
        // Обрабатываем запросы
        for (int i = 0; i  0 && isOne[index - 1]) {
                union(index - 1, index);
            }
            
            // Проверяем, можно ли объединить с правым соседом
            if (index < isOne.length - 1 && isOne[index + 1]) {
                union(index, index + 1);
            }
        }
        
        /**
         Возвращает количество непрерывных отрезков из единиц
         */
        public int countSegments() {
            return segmentCount;
        }
    }
}

Подробное объяснение

Структура данных

СНМ для отслеживания непрерывных отрезков:
parent[] - хранит родителя каждого элемента массива
isOne[] - булев массив, отслеживающий, равен ли элемент 1
segmentCount - счетчик непрерывных отрезков из единиц

Основные операции

find(x) - находит корень (представителя) множества, содержащего элемент x:
Использует оптимизацию "сжатие путей" для ускорения последующих операций
Амортизированная сложность: O(α(n)), где α(n) - обратная функция Аккермана (практически константа)

union(x, y) - объединяет множества, содержащие элементы x и y:
Если элементы уже в одном множестве, ничего не делает
Иначе объединяет множества и уменьшает счетчик сегментов
Сложность: O(α(n))

setOne(index) - устанавливает значение a[index] = 1:
Если элемент уже равен 1, ничего не делает
Иначе устанавливает элемент в 1 и увеличивает счетчик сегментов
Проверяет, можно ли объединить с левым и/или правым соседом
Если соседи равны 1, объединяет сегменты
Сложность: O(α(n))

countSegments() - возвращает количество непрерывных отрезков из единиц:
Просто возвращает значение переменной segmentCount
Сложность: O(1)

Процесс работы алгоритма

Инициализация:
Создаем массив родителей, где каждый элемент является корнем своего множества
Создаем булев массив isOne, изначально заполненный значениями false (все элементы равны 0)
Устанавливаем счетчик сегментов в 0

Установка элемента в 1 (setOne(index)):
Если элемент уже равен 1, ничего не делаем
Иначе:
Устанавливаем isOne[index] = true
Увеличиваем счетчик сегментов на 1
Проверяем левого соседа (если он существует и равен 1):
Объединяем текущий элемент с левым соседом
Уменьшаем счетчик сегментов на 1 (так как два сегмента объединяются в один)
Проверяем правого соседа (если он существует и равен 1):
Объединяем текущий элемент с правым соседом
Уменьшаем счетчик сегментов на 1 (если это новое объединение)

Подсчет сегментов (countSegments()):
Возвращаем текущее значение счетчика сегментов

Пример работы алгоритма

Рассмотрим массив размера 5, изначально заполненный нулями: [0, 0, 0, 0, 0]

setOne(2): [0, 0, 1, 0, 0]
isOne[2] = true
segmentCount = 1
Нет соседей со значением 1, объединять нечего

setOne(0): [1, 0, 1, 0, 0]
isOne[0] = true
segmentCount = 2
Нет соседей со значением 1, объединять нечего

setOne(1): [1, 1, 1, 0, 0]
isOne[1] = true
segmentCount = 3
Левый сосед (0) равен 1, объединяем: segmentCount = 2
Правый сосед (2) равен 1, объединяем: segmentCount = 1

countSegments(): возвращает 1

setOne(4): [1, 1, 1, 0, 1]
isOne[4] = true
segmentCount = 2
Нет соседей со значением 1, объединять нечего

countSegments(): возвращает 2

Сложность алгоритма

Временная сложность:
Для каждой операции (установка элемента в 1 или подсчет сегментов) - O(α(n)), где α(n) - обратная функция Аккермана
Для q операций - O(q × α(n))
Поскольку α(n) растет очень медленно и для всех практических значений n не превышает 4, можно считать, что сложность практически линейная O(q)

Пространственная сложность: O(n) для хранения массивов parent и isOne.

Заключение

Данное решение эффективно обрабатывает оба типа запросов, используя СНМ для отслеживания и объединения непрерывных отрезков из единиц. Благодаря оптимизации "сжатие путей", все операции выполняются за практически константное время, что делает решение эффективным даже для больших массивов и большого количества запросов.

Ключевая идея решения заключается в том, что мы используем СНМ для представления непрерывных отрезков из единиц как отдельных множеств. Когда мы устанавливаем новый элемент в 1, мы проверяем его соседей и, если они также равны 1, объединяем соответствующие множества, уменьшая счетчик сегментов.