Решение: Подсчет ребер в компоненте связности динамического графа

Введение

В этой задаче нам нужно реализовать структуру данных для работы с динамическим графом, которая поддерживает два типа операций:
Добавление ребра между двумя вершинами
Подсчет количества ребер в компоненте связности, содержащей заданную вершину

Для эффективного решения этой задачи мы будем использовать Систему Непересекающихся Множеств (СНМ, или DSU - Disjoint Set Union) с дополнительной информацией о количестве ребер в каждой компоненте.

Реализация на Java

import java.util.*;

public class GraphEdgeCounter {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Считываем количество вершин и запросов
        int n = scanner.nextInt(); // Количество вершин
        int q = scanner.nextInt(); // Количество запросов
        
        // Создаем структуру данных для работы с графом
        EdgeCountingDSU dsu = new EdgeCountingDSU(n);
        
        // Обрабатываем запросы
        for (int i = 0; i < q; i++) {
            int queryType = scanner.nextInt();
            
            if (queryType == 1) {
                // Запрос 1: добавить ребро
                int u = scanner.nextInt() - 1; // Вычитаем 1, если вершины нумеруются с 1
                int v = scanner.nextInt() - 1;
                dsu.addEdge(u, v);
            } else if (queryType == 2) {
                // Запрос 2: найти число ребер в компоненте связности
                int x = scanner.nextInt() - 1; // Вычитаем 1, если вершины нумеруются с 1
                System.out.println(dsu.getEdgeCount(x));
            }
        }
    }
    
    static class EdgeCountingDSU {
        private int[] parent;    // Массив родителей для СНМ
        private int[] rank;      // Ранг для оптимизации объединения
        private int[] size;      // Размер каждой компоненты (число вершин)
        private int[] edgeCount; // Количество ребер в каждой компоненте
        
        /**
         Инициализация структуры данных для графа с n вершинами
         */
        public EdgeCountingDSU(int n) {
            parent = new int[n];
            rank = new int[n];
            size = new int[n];
            edgeCount = new int[n];
            
            // Каждая вершина изначально в своей компоненте
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                rank[i] = 0;
                size[i] = 1;
                edgeCount[i] = 0; // Изначально в компоненте нет ребер
            }
        }
        
        /**
         Находит корень (представителя) компоненты, содержащей вершину x
         */
        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]); // Сжатие путей
            }
            return parent[x];
        }
        
        /**
         Добавляет ребро между вершинами u и v
         */
        public void addEdge(int u, int v) {
            int rootU = find(u);
            int rootV = find(v);
            
            // Если вершины уже в одной компоненте, просто добавляем ребро
            if (rootU == rootV) {
                edgeCount[rootU]++;
                return;
            }
            
            // Объединяем компоненты по рангу
            if (rank[rootU] < rank[rootV]) {
                // rootU становится потомком rootV
                parent[rootU] = rootV;
                
                // Обновляем информацию о компоненте rootV
                size[rootV] += size[rootU];
                edgeCount[rootV] += edgeCount[rootU] + 1; // +1 за новое ребро (u, v)
            } else {
                // rootV становится потомком rootU
                parent[rootV] = rootU;
                
                // Обновляем информацию о компоненте rootU
                size[rootU] += size[rootV];
                edgeCount[rootU] += edgeCount[rootV] + 1; // +1 за новое ребро (u, v)
                
                // Если ранги равны, увеличиваем ранг rootU
                if (rank[rootU] == rank[rootV]) {
                    rank[rootU]++;
                }
            }
        }
        
        /**
         Возвращает количество ребер в компоненте, содержащей вершину x
         */
        public int getEdgeCount(int x) {
            int root = find(x);
            return edgeCount[root];
        }
        
        /**
         Возвращает размер компоненты (число вершин), содержащей вершину x
         */
        public int getSize(int x) {
            int root = find(x);
            return size[root];
        }
    }
}

Подробное объяснение

Структура данных

СНМ с дополнительной информацией:
parent[] - хранит родителя каждой вершины
rank[] - хранит ранг (приблизительную высоту) каждого поддерева для оптимизации объединения
size[] - хранит количество вершин в каждой компоненте
edgeCount[] - хранит количество ребер в каждой компоненте

Основные операции

find(x) - находит корень компоненты, содержащей вершину x:
Использует оптимизацию "сжатие путей" для ускорения последующих операций
Амортизированная сложность: O(α(n)), где α(n) - обратная функция Аккермана (практически константа)

addEdge(u, v) - добавляет ребро между вершинами u и v:
Находит корни компонент, содержащих u и v
Если вершины уже в одной компоненте, просто увеличивает счетчик ребер
Иначе объединяет компоненты, используя эвристику "объединение по рангу"
Обновляет информацию о размере и количестве ребер в результирующей компоненте
Сложность: O(α(n))

getEdgeCount(x) - возвращает количество ребер в компоненте, содержащей вершину x:
Находит корень компоненты и возвращает значение счетчика ребер
Сложность: O(α(n))

Процесс работы алгоритма

Инициализация:
Создаем n компонент, каждая содержит одну вершину
Размер каждой компоненты равен 1
Количество ребер в каждой компоненте равно 0

Добавление ребра (u, v):
Если u и v уже в одной компоненте:
Просто увеличиваем счетчик ребер в этой компоненте
Если u и v в разных компонентах:
Объединяем компоненты по рангу
Обновляем размер объединенной компоненты
Обновляем количество ребер в объединенной компоненте:
Сумма ребер обеих компонент + 1 (новое ребро)

Запрос количества ребер:
Находим корень компоненты, содержащей вершину x
Возвращаем значение счетчика ребер для этой компоненты

Оптимизации

Сжатие путей - при поиске корня компоненты все вершины на пути переподключаются напрямую к корню, что ускоряет последующие операции.

Объединение по рангу - при объединении компонент компонента с меньшим рангом присоединяется к компоненте с большим рангом, что минимизирует высоту дерева и ускоряет операции поиска.

Важные детали реализации

Обработка случая, когда ребро добавляется внутри компоненты:
Если ребро добавляется между вершинами, которые уже находятся в одной компоненте, мы просто увеличиваем счетчик ребер для этой компоненты.

Обновление счетчика ребер при объединении компонент:
При объединении компонент A и B количество ребер в результирующей компоненте равно:
Количество ребер в A + Количество ребер в B + 1 (новое ребро)

Сложность алгоритма

Временная сложность:
Для каждой операции (добавление ребра или запрос) - O(α(n)), где α(n) - обратная функция Аккермана
Для q операций - O(q × α(n))
Поскольку α(n) растет очень медленно и для всех практических значений n не превышает 4, можно считать, что сложность практически линейная O(q)

Пространственная сложность: O(n) для хранения массивов parent, rank, size и edgeCount.

Заключение

Данное решение эффективно обрабатывает оба типа запросов, используя СНМ с дополнительной информацией о количестве ребер в каждой компоненте. Благодаря оптимизациям "сжатие путей" и "объединение по рангу", все операции выполняются за практически константное время, что делает решение эффективным даже для больших графов и большого количества запросов.