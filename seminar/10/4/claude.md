Решение: Подсчет компонент связности, являющихся деревьями

Введение

В этой задаче нам нужно реализовать структуру данных для работы с динамическим графом, которая поддерживает два типа операций:
Добавление ребра между двумя вершинами
Подсчет количества компонент связности, которые являются деревьями

Напомним, что дерево - это связный граф без циклов. Для компоненты связности с n вершинами, чтобы быть деревом, она должна содержать ровно n-1 ребро.

Подход к решению

Для решения этой задачи мы будем использовать Систему Непересекающихся Множеств (СНМ, или DSU - Disjoint Set Union) с дополнительной информацией о каждой компоненте:
Количество вершин в компоненте
Количество ребер в компоненте
Является ли компонента деревом

Реализация на Java

import java.util.*;

public class TreeComponentCounter {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Считываем количество вершин и запросов
        int n = scanner.nextInt(); // Количество вершин
        int q = scanner.nextInt(); // Количество запросов
        
        // Создаем структуру данных для работы с графом
        TreeComponentDSU dsu = new TreeComponentDSU(n);
        
        // Обрабатываем запросы
        for (int i = 0; i < q; i++) {
            int queryType = scanner.nextInt();
            
            if (queryType == 1) {
                // Запрос 1: добавить ребро
                int u = scanner.nextInt() - 1; // Вычитаем 1, если вершины нумеруются с 1
                int v = scanner.nextInt() - 1;
                dsu.addEdge(u, v);
            } else if (queryType == 2) {
                // Запрос 2: найти число компонент связности, являющихся деревьями
                System.out.println(dsu.countTreeComponents());
            }
        }
    }
    
    static class TreeComponentDSU {
        private int[] parent;    // Массив родителей для СНМ
        private int[] rank;      // Ранг для оптимизации объединения
        private int[] size;      // Размер каждой компоненты (число вершин)
        private int[] edgeCount; // Количество ребер в каждой компоненте
        private boolean[] isTree; // Флаг, указывающий, является ли компонента деревом
        private int treeComponents; // Количество компонент, являющихся деревьями
        
        /**
         Инициализация структуры данных для графа с n вершинами
         */
        public TreeComponentDSU(int n) {
            parent = new int[n];
            rank = new int[n];
            size = new int[n];
            edgeCount = new int[n];
            isTree = new boolean[n];
            
            // Каждая вершина изначально в своей компоненте
            for (int i = 0; i < n; i++) {
                parent[i] = i;
                rank[i] = 0;
                size[i] = 1;
                edgeCount[i] = 0;
                isTree[i] = true; // Изначально каждая компонента (одна вершина) - дерево
            }
            
            treeComponents = n; // Изначально все n компонент являются деревьями
        }
        
        /**
         Находит корень (представителя) компоненты, содержащей вершину x
         */
        public int find(int x) {
            if (parent[x] != x) {
                parent[x] = find(parent[x]); // Сжатие путей
            }
            return parent[x];
        }
        
        /**
         Добавляет ребро между вершинами u и v
         */
        public void addEdge(int u, int v) {
            int rootU = find(u);
            int rootV = find(v);
            
            // Если вершины уже в одной компоненте, добавление ребра создает цикл
            if (rootU == rootV) {
                if (isTree[rootU]) {
                    isTree[rootU] = false; // Компонента перестает быть деревом
                    treeComponents--;
                }
                edgeCount[rootU]++;
                return;
            }
            
            // Объединяем компоненты по рангу
            if (rank[rootU] < rank[rootV]) {
                // rootU становится потомком rootV
                parent[rootU] = rootV;
                
                // Обновляем информацию о компоненте rootV
                int newSize = size[rootV] + size[rootU];
                int newEdgeCount = edgeCount[rootV] + edgeCount[rootU] + 1; // +1 за новое ребро (u, v)
                
                // Проверяем, является ли объединенная компонента деревом
                boolean wasTreeV = isTree[rootV];
                boolean wasTreeU = isTree[rootU];
                boolean newIsTree = (newEdgeCount == newSize - 1) && wasTreeU && wasTreeV;
                
                // Обновляем счетчик компонент-деревьев
                if (wasTreeU) treeComponents--;
                if (wasTreeV) treeComponents--;
                if (newIsTree) treeComponents++;
                
                // Обновляем информацию о компоненте
                size[rootV] = newSize;
                edgeCount[rootV] = newEdgeCount;
                isTree[rootV] = newIsTree;
                
            } else {
                // rootV становится потомком rootU
                parent[rootV] = rootU;
                
                // Обновляем информацию о компоненте rootU
                int newSize = size[rootU] + size[rootV];
                int newEdgeCount = edgeCount[rootU] + edgeCount[rootV] + 1; // +1 за новое ребро (u, v)
                
                // Проверяем, является ли объединенная компонента деревом
                boolean wasTreeU = isTree[rootU];
                boolean wasTreeV = isTree[rootV];
                boolean newIsTree = (newEdgeCount == newSize - 1) && wasTreeU && wasTreeV;
                
                // Обновляем счетчик компонент-деревьев
                if (wasTreeU) treeComponents--;
                if (wasTreeV) treeComponents--;
                if (newIsTree) treeComponents++;
                
                // Обновляем информацию о компоненте
                size[rootU] = newSize;
                edgeCount[rootU] = newEdgeCount;
                isTree[rootU] = newIsTree;
                
                // Если ранги равны, увеличиваем ранг rootU
                if (rank[rootU] == rank[rootV]) {
                    rank[rootU]++;
                }
            }
        }
        
        /**
         Возвращает количество компонент связности, являющихся деревьями
         */
        public int countTreeComponents() {
            return treeComponents;
        }
    }
}

Подробное объяснение

Структура данных

СНМ с дополнительной информацией:
parent[] - хранит родителя каждой вершины
rank[] - хранит ранг (приблизительную высоту) каждого поддерева для оптимизации объединения
size[] - хранит количество вершин в каждой компоненте
edgeCount[] - хранит количество ребер в каждой компоненте
isTree[] - флаг, указывающий, является ли компонента деревом
treeComponents - общее количество компонент, являющихся деревьями

Основные операции

find(x) - находит корень компоненты, содержащей вершину x:
Использует оптимизацию "сжатие путей" для ускорения последующих операций
Амортизированная сложность: O(α(n)), где α(n) - обратная функция Аккермана (практически константа)

addEdge(u, v) - добавляет ребро между вершинами u и v:
Находит корни компонент, содержащих u и v
Если вершины уже в одной компоненте, добавление ребра создает цикл:
Компонента перестает быть деревом (если была им)
Увеличиваем счетчик ребер в компоненте
Иначе объединяем компоненты:
Используем эвристику "объединение по рангу"
Обновляем размер и количество ребер в результирующей компоненте
Проверяем, является ли объединенная компонента деревом
Обновляем счетчик компонент-деревьев
Сложность: O(α(n))

countTreeComponents() - возвращает количество компонент связности, являющихся деревьями:
Просто возвращает значение переменной treeComponents
Сложность: O(1)

Процесс работы алгоритма

Инициализация:
Создаем n компонент, каждая содержит одну вершину
Размер каждой компоненты равен 1
Количество ребер в каждой компоненте равно 0
Каждая компонента изначально является деревом
Общее количество компонент-деревьев равно n

Добавление ребра (u, v):
Если u и v уже в одной компоненте:
Добавление ребра создает цикл
Компонента перестает быть деревом (если была им)
Уменьшаем счетчик компонент-деревьев
Если u и v в разных компонентах:
Объединяем компоненты
Обновляем размер и количество ребер в объединенной компоненте
Проверяем, является ли объединенная компонента деревом:
Компонента является деревом, если количество ребер = количество вершин - 1
И обе исходные компоненты были деревьями
Обновляем счетчик компонент-деревьев

Запрос количества компонент-деревьев:
Возвращаем значение переменной treeComponents

Ключевые моменты реализации

Определение дерева:
Дерево - это связный граф без циклов
Для компоненты с n вершинами, чтобы быть деревом, она должна содержать ровно n-1 ребро
Если добавление ребра создает цикл, компонента перестает быть деревом

Обновление счетчика компонент-деревьев:
При объединении двух компонент:
Если обе компоненты были деревьями, уменьшаем счетчик на 2
Если объединенная компонента является деревом, увеличиваем счетчик на 1
При добавлении ребра, создающего цикл:
Если компонента была деревом, уменьшаем счетчик на 1

Оптимизации:
"Сжатие путей" при поиске корня компоненты
"Объединение по рангу" при объединении компонент

Сложность алгоритма

Временная сложность:
Для каждой операции (добавление ребра или запрос) - O(α(n)), где α(n) - обратная функция Аккермана
Для q операций - O(q × α(n))
Поскольку α(n) растет очень медленно и для всех практических значений n не превышает 4, можно считать, что сложность практически линейная O(q)

Пространственная сложность: O(n) для хранения массивов parent, rank, size, edgeCount и isTree.

Заключение

Данное решение эффективно обрабатывает оба типа запросов, используя СНМ с дополнительной информацией о компонентах связности. Ключевым моментом является отслеживание, является ли компонента деревом, на основе соотношения между количеством вершин и ребер, а также учет создания циклов при добавлении ребер.