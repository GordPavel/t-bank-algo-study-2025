Решение: Минимальное остовное дерево в взвешенном графе

Введение

В этой задаче нам дан взвешенный граф, и нужно удалить некоторые ребра так, чтобы граф остался связным, а сумма весов оставшихся ребер была минимальной. Это классическая задача нахождения минимального остовного дерева (Minimum Spanning Tree, MST).

Минимальное остовное дерево - это подграф исходного графа, который:
Является деревом (связный граф без циклов)
Содержит все вершины исходного графа
Имеет минимальную возможную сумму весов ребер

Для решения этой задачи мы можем использовать один из двух классических алгоритмов:
Алгоритм Прима
Алгоритм Крускала

В данном решении мы будем использовать алгоритм Крускала, так как он обычно проще в реализации и эффективен для разреженных графов.

Алгоритм Крускала

Алгоритм Крускала работает следующим образом:
Отсортировать все ребра графа по возрастанию веса
Изначально каждая вершина образует отдельное множество
Перебирать ребра в порядке возрастания веса:
Если ребро соединяет вершины из разных множеств, добавить его в MST и объединить множества
Иначе пропустить ребро (оно образует цикл)
Процесс завершается, когда все вершины оказываются в одном множестве

Для эффективной реализации алгоритма Крускала используется структура данных "Система непересекающихся множеств" (Disjoint Set Union, DSU).

Реализация на Java
```java
import java.util.*;

public class MinimumSpanningTree {

    // Класс для представления ребра графа
    static class Edge implements Comparable {
        int src;    // Исходная вершина
        int dest;   // Конечная вершина
        int weight; // Вес ребра
        
        public Edge(int src, int dest, int weight) {
            this.src = src;
            this.dest = dest;
            this.weight = weight;
        }
        
        // Сравнение ребер по весу для сортировки
        @Override
        public int compareTo(Edge other) {
            return Integer.compare(this.weight, other.weight);
        }
    }
    
    // Класс для реализации системы непересекающихся множеств (DSU)
    static class DisjointSet {
        int[] parent; // Массив родителей
        int[] rank;   // Ранг для оптимизации объединения
        
        public DisjointSet(int n) {
            parent = new int[n];
            rank = new int[n];
            
            // Изначально каждая вершина является корнем своего множества
            for (int i = 0; i  rank[rootY]) {
                parent[rootY] = rootX;
            } else {
                parent[rootY] = rootX;
                rank[rootX]++;
            }
        }
    }
    
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Считываем количество вершин и ребер
        int n = scanner.nextInt(); // Количество вершин
        int m = scanner.nextInt(); // Количество ребер
        
        // Создаем список ребер
        List edges = new ArrayList();
        
        // Считываем ребра
        for (int i = 0; i  mst = kruskalMST(edges, n);
        
        // Вычисляем сумму весов ребер в MST
        int totalWeight = 0;
        for (Edge edge : mst) {
            totalWeight += edge.weight;
        }
        
        // Выводим результат
        System.out.println("Минимальная сумма весов: " + totalWeight);
        System.out.println("Ребра в минимальном остовном дереве:");
        for (Edge edge : mst) {
            // Добавляем 1, если вершины нумеруются с 1
            System.out.println((edge.src + 1) + " - " + (edge.dest + 1) + " : " + edge.weight);
        }
    }
    
    /**
     Находит минимальное остовное дерево с помощью алгоритма Крускала
     * @param edges список ребер графа
     @param n количество вершин
     @return список ребер, образующих минимальное остовное дерево
     */
    public static List kruskalMST(List edges, int n) {
        // Сортируем ребра по весу
        Collections.sort(edges);
        
        // Создаем систему непересекающихся множеств
        DisjointSet dsu = new DisjointSet(n);
        
        // Список для хранения ребер MST
        List mst = new ArrayList();
        
        // Перебираем ребра в порядке возрастания веса
        for (Edge edge : edges) {
            int srcRoot = dsu.find(edge.src);
            int destRoot = dsu.find(edge.dest);
            
            // Если ребро не образует цикл, добавляем его в MST
            if (srcRoot != destRoot) {
                mst.add(edge);
                dsu.union(srcRoot, destRoot);
            }
            
            // Если MST содержит n-1 ребер, завершаем алгоритм
            if (mst.size() == n - 1) {
                break;
            }
        }
        
        return mst;
    }
}
```
Подробное объяснение

Структуры данных

Edge - класс для представления ребра графа:
src - исходная вершина
dest - конечная вершина
weight - вес ребра
Реализует интерфейс Comparable для сортировки ребер по весу

DisjointSet - класс для реализации системы непересекающихся множеств:
parent[] - массив родителей, где parent[i] - родитель вершины i
rank[] - массив рангов для оптимизации объединения
find(x) - находит корень множества, содержащего элемент x (с оптимизацией сжатия путей)
union(x, y) - объединяет множества, содержащие элементы x и y (с оптимизацией по рангу)

Алгоритм Крускала

Сортировка ребер:
Сортируем все ребра графа по возрастанию веса
Это позволяет рассматривать ребра в порядке возрастания веса

Инициализация DSU:
Создаем систему непересекающихся множеств, где каждая вершина изначально образует отдельное множество

Построение MST:
Перебираем ребра в порядке возрастания веса
Для каждого ребра (u, v):
Находим корни множеств, содержащих вершины u и v
Если вершины находятся в разных множествах (корни различны):
Добавляем ребро в MST
Объединяем множества
Иначе пропускаем ребро (оно образует цикл)
Процесс завершается, когда MST содержит n-1 ребер (где n - количество вершин)

Пример работы алгоритма

Рассмотрим граф с 4 вершинами и 5 ребрами:
1 -- 2
|    |
|    |
3 -- 4

Веса ребер:
(1, 2): 10
(1, 3): 6
(2, 4): 15
(3, 4): 5
(1, 4): 8

Сортировка ребер по весу:
(3, 4): 5
(1, 3): 6
(1, 4): 8
(1, 2): 10
(2, 4): 15

Инициализация DSU:
parent = [0, 1, 2, 3]
rank = [0, 0, 0, 0]

Построение MST:
Рассматриваем ребро (3, 4) с весом 5:
find(3) = 3, find(4) = 4 (разные множества)
Добавляем ребро в MST
Объединяем множества: parent = [0, 1, 2, 3], rank = [0, 0, 0, 1]
Рассматриваем ребро (1, 3) с весом 6:
find(1) = 1, find(3) = 3 (разные множества)
Добавляем ребро в MST
Объединяем множества: parent = [0, 1, 2, 1], rank = [0, 1, 0, 1]
Рассматриваем ребро (1, 4) с весом 8:
find(1) = 1, find(4) = 1 (одно множество)
Пропускаем ребро (образует цикл)
Рассматриваем ребро (1, 2) с весом 10:
find(1) = 1, find(2) = 2 (разные множества)
Добавляем ребро в MST
Объединяем множества: parent = [0, 1, 1, 1], rank = [0, 1, 0, 1]
MST содержит 3 ребра (n-1 = 3), завершаем алгоритм

Результат:
MST содержит ребра: (3, 4), (1, 3), (1, 2)
Сумма весов: 5 + 6 + 10 = 21

Оптимизации в DSU

Сжатие путей (Path Compression):
При выполнении операции find(x) все вершины на пути от x до корня становятся непосредственными потомками корня
Это уменьшает глубину дерева и ускоряет последующие операции find

Объединение по рангу (Union by Rank):
При объединении двух множеств множество с меньшим рангом присоединяется к множеству с большим рангом
Если ранги равны, произвольно выбирается одно множество и его ранг увеличивается на 1
Это помогает сохранять деревья сбалансированными и уменьшает их высоту

Сложность алгоритма

Временная сложность: O(m log m), где m - количество ребер
Сортировка ребер: O(m log m)
Операции с DSU: O(m log* n), где log* - итерированный логарифм (очень медленно растущая функция)
Общая сложность определяется сортировкой: O(m log m)

Пространственная сложность: O(n + m)
O(n) для хранения DSU
O(m) для хранения списка ребер и MST

Заключение

Алгоритм Крускала является эффективным решением для нахождения минимального остовного дерева в взвешенном графе. Он позволяет удалить лишние ребра так, чтобы граф остался связным, а сумма весов оставшихся ребер была минимальной.

Ключевые моменты решения:
Сортировка ребер по весу для рассмотрения их в порядке возрастания
Использование DSU для эффективного отслеживания компонент связности
Добавление ребра в MST только если оно не образует цикл
Оптимизации в DSU (сжатие путей и объединение по рангу) для повышения эффективности

Это решение работает для любого связного неориентированного взвешенного графа и находит минимальное остовное дерево за O(m log m) времени.