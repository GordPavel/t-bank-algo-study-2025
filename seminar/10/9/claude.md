Решение: Подсчет отрезков, где число является минимумом

Введение

В этой задаче нам нужно для каждого элемента массива найти количество различных отрезков, в которых этот элемент является минимальным.

Для решения этой задачи мы можем использовать следующий подход: для каждого элемента массива найдем максимальный отрезок, в котором этот элемент является минимальным. Затем подсчитаем, сколько различных подотрезков содержит этот максимальный отрезок.

Алгоритм решения

Для каждого элемента a[i] найдем:
Ближайший элемент слева, который меньше a[i]
Ближайший элемент справа, который меньше a[i]
Это даст нам границы максимального отрезка, в котором a[i] является минимумом
Подсчитаем количество различных подотрезков в этом максимальном отрезке, которые содержат a[i]

Для эффективного нахождения ближайших меньших элементов мы можем использовать структуру данных "монотонный стек".

Реализация на Java

import java.util.*;

public class MinimumElementInSubarrays {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Считываем размер массива
        int n = scanner.nextInt();
        
        // Считываем элементы массива
        int[] a = new int[n];
        for (int i = 0; i  stack = new Stack();
        
        // Находим ближайший меньший элемент слева
        for (int i = 0; i = a[i]) {
                stack.pop();
            }
            
            // Если стек не пуст, верхний элемент - ближайший меньший слева
            if (!stack.isEmpty()) {
                leftSmaller[i] = stack.peek();
            }
            
            // Добавляем текущий индекс в стек
            stack.push(i);
        }
        
        // Очищаем стек для повторного использования
        stack.clear();
        
        // Находим ближайший меньший элемент справа
        for (int i = n - 1; i >= 0; i--) {
            // Удаляем из стека все элементы, которые не меньше текущего
            while (!stack.isEmpty() && a[stack.peek()] >= a[i]) {
                stack.pop();
            }
            
            // Если стек не пуст, верхний элемент - ближайший меньший справа
            if (!stack.isEmpty()) {
                rightSmaller[i] = stack.peek();
            }
            
            // Добавляем текущий индекс в стек
            stack.push(i);
        }
        
        // Массив для хранения результатов
        long[] result = new long[n];
        
        // Для каждого элемента подсчитываем количество отрезков
        for (int i = 0; i < n; i++) {
            // Находим границы максимального отрезка, где a[i] - минимум
            int left = leftSmaller[i] + 1;  // Левая граница (включительно)
            int right = rightSmaller[i] - 1; // Правая граница (включительно)
            
            // Подсчитываем количество отрезков, содержащих a[i] как минимум
            // Формула: (i - left + 1) * (right - i + 1)
            // Это произведение количества возможных левых границ на количество возможных правых границ
            long leftCount = i - left + 1;
            long rightCount = right - i + 1;
            result[i] = leftCount * rightCount;
        }
        
        return result;
    }
}

Подробное объяснение

Основная идея

Для каждого элемента a[i] мы хотим найти все отрезки, в которых этот элемент является минимальным. Ключевое наблюдение: a[i] является минимумом в отрезке [l, r] тогда и только тогда, когда:
l ≤ i ≤ r (элемент a[i] входит в отрезок)
Все элементы в отрезке [l, i-1] не меньше a[i]
Все элементы в отрезке [i+1, r] не меньше a[i]

Таким образом, для каждого a[i] мы можем найти максимальный отрезок [left, right], в котором a[i] является минимумом:
left - это индекс следующий за ближайшим элементом слева, который меньше a[i]
right - это индекс предыдущий перед ближайшим элементом справа, который меньше a[i]

Затем мы можем подсчитать количество различных подотрезков в [left, right], которые содержат a[i]:
Для левой границы подотрезка есть (i - left + 1) вариантов: left, left+1, ..., i
Для правой границы подотрезка есть (right - i + 1) вариантов: i, i+1, ..., right
Общее количество подотрезков: (i - left + 1) * (right - i + 1)

Монотонный стек

Для эффективного нахождения ближайших меньших элементов мы используем структуру данных "монотонный стек". Это стек, в котором элементы поддерживаются в порядке возрастания (или убывания).

Нахождение ближайшего меньшего элемента слева:
Перебираем элементы массива слева направо
Для каждого элемента a[i]:
Удаляем из стека все элементы, значения которых не меньше a[i]
Если стек не пуст, верхний элемент стека - ближайший меньший элемент слева
Добавляем индекс i в стек

Нахождение ближайшего меньшего элемента справа:
Перебираем элементы массива справа налево
Для каждого элемента a[i]:
Удаляем из стека все элементы, значения которых не меньше a[i]
Если стек не пуст, верхний элемент стека - ближайший меньший элемент справа
Добавляем индекс i в стек

Подсчет отрезков

После нахождения границ максимального отрезка [left, right], в котором a[i] является минимумом, мы подсчитываем количество различных подотрезков:

Для левой границы подотрезка есть (i - left + 1) вариантов
Для правой границы подотрезка есть (right - i + 1) вариантов
Общее количество подотрезков: (i - left + 1) * (right - i + 1)

Пример работы алгоритма

Рассмотрим массив [3, 1, 4, 1, 5]:

Находим ближайшие меньшие элементы слева:
leftSmaller = [-1, -1, 1, -1, 3]

Находим ближайшие меньшие элементы справа:
rightSmaller = [1, 3, 3, 5, 5]

Подсчитываем количество отрезков для каждого элемента:
Для a[0] = 3:
left = -1 + 1 = 0
right = 1 - 1 = 0
leftCount = 0 - 0 + 1 = 1
rightCount = 0 - 0 + 1 = 1
result[0] = 1 * 1 = 1
Для a[1] = 1:
left = -1 + 1 = 0
right = 3 - 1 = 2
leftCount = 1 - 0 + 1 = 2
rightCount = 2 - 1 + 1 = 2
result[1] = 2 * 2 = 4
Для a[2] = 4:
left = 1 + 1 = 2
right = 3 - 1 = 2
leftCount = 2 - 2 + 1 = 1
rightCount = 2 - 2 + 1 = 1
result[2] = 1 * 1 = 1
Для a[3] = 1:
left = -1 + 1 = 0
right = 5 - 1 = 4
leftCount = 3 - 0 + 1 = 4
rightCount = 4 - 3 + 1 = 2
result[3] = 4 * 2 = 8
Для a[4] = 5:
left = 3 + 1 = 4
right = 5 - 1 = 4
leftCount = 4 - 4 + 1 = 1
rightCount = 4 - 4 + 1 = 1
result[4] = 1 * 1 = 1

Результат: [1, 4, 1, 8, 1]

Проверка результата

Давайте проверим результат для a[1] = 1:
Отрезки, в которых a[1] является минимумом: [0,1], [1,1], [1,2], [0,1,2]
Всего 4 отрезка, что соответствует нашему результату result[1] = 4

Для a[3] = 1:
Отрезки, в которых a[3] является минимумом: [0,1,2,3], [1,2,3], [2,3], [3,3], [3,4], [2,3,4], [1,2,3,4], [0,1,2,3,4]
Всего 8 отрезков, что соответствует нашему результату result[3] = 8

Сложность алгоритма

Временная сложность: O(n), где n - размер массива
Нахождение ближайших меньших элементов слева: O(n)
Нахождение ближайших меньших элементов справа: O(n)
Подсчет отрезков для каждого элемента: O(n)

Пространственная сложность: O(n) для хранения массивов leftSmaller, rightSmaller, result и стека.

Заключение

Данное решение эффективно находит для каждого элемента массива количество отрезков, в которых этот элемент является минимальным. Ключевым моментом является использование монотонного стека для нахождения ближайших меньших элементов, что позволяет определить границы максимального отрезка, в котором элемент является минимумом.

Затем мы используем простую формулу для подсчета количества различных подотрезков, что дает нам окончательный результат за линейное время.