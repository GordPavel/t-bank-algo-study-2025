Решение: Поиск минимальных расстояний от вершины s до всех остальных вершин во взвешенном графе
Введение
В этой задаче нам нужно найти минимальные расстояния от заданной вершины s до всех остальных вершин во взвешенном графе. Это классическая задача поиска кратчайших путей из одной вершины, для решения которой обычно используется алгоритм Дейкстры.

Алгоритм Дейкстры эффективно находит кратчайшие пути от одной вершины до всех остальных в графе с неотрицательными весами рёбер. Если в графе могут быть отрицательные веса рёбер, то следует использовать алгоритм Беллмана-Форда.

В данном решении мы реализуем алгоритм Дейкстры, так как в условии не указано, что веса рёбер могут быть отрицательными.

Алгоритм Дейкстры
Алгоритм Дейкстры работает следующим образом:

Инициализируем массив расстояний dist[], где dist[v] - минимальное расстояние от s до v. Изначально dist[s] = 0, а для всех остальных вершин dist[v] = бесконечность.
Создаем приоритетную очередь (или множество) для хранения пар (вершина, расстояние), отсортированных по расстоянию.
Добавляем начальную вершину s в очередь с расстоянием 0.
Пока очередь не пуста:
Извлекаем вершину u с минимальным расстоянием из очереди.
Для каждого соседа v вершины u:
Если dist[u] + вес(u, v) < dist[v], то обновляем dist[v] = dist[u] + вес(u, v) и добавляем v в очередь.
Реализация на Java
```java
import java.util.*;

public class DijkstraShortestPath {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Считываем количество вершин, рёбер и начальную вершину
        int n = scanner.nextInt(); // Количество вершин
        int m = scanner.nextInt(); // Количество рёбер
        int s = scanner.nextInt(); // Начальная вершина
        
        // Создаем список смежности для представления графа
        List<List<Edge>> graph = new ArrayList<>();
        for (int i = 0; i <= n; i++) {
            graph.add(new ArrayList<>());
        }
        
        // Считываем рёбра
        for (int i = 0; i < m; i++) {
            int u = scanner.nextInt();
            int v = scanner.nextInt();
            int weight = scanner.nextInt();
            
            // Добавляем ребро в список смежности
            graph.get(u).add(new Edge(v, weight));
            
            // Если граф неориентированный, добавляем обратное ребро
            // graph.get(v).add(new Edge(u, weight));
        }
        
        // Находим кратчайшие пути от вершины s до всех остальных
        long[] distances = dijkstra(graph, s, n);
        
        // Выводим результат
        for (int i = 1; i <= n; i++) {
            if (i == s) {
                System.out.println("0");
            } else if (distances[i] == Long.MAX_VALUE) {
                System.out.println("INF");
            } else {
                System.out.println(distances[i]);
            }
        }
    }
    
    /**
     * Класс для представления ребра графа
     */
    static class Edge {
        int to;     // Конечная вершина
        int weight; // Вес ребра
        
        public Edge(int to, int weight) {
            this.to = to;
            this.weight = weight;
        }
    }
    
    /**
     * Класс для хранения пары (вершина, расстояние) в приоритетной очереди
     */
    static class Node implements Comparable<Node> {
        int vertex;   // Вершина
        long distance; // Расстояние от начальной вершины
        
        public Node(int vertex, long distance) {
            this.vertex = vertex;
            this.distance = distance;
        }
        
        @Override
        public int compareTo(Node other) {
            return Long.compare(this.distance, other.distance);
        }
    }
    
    /**
     * Алгоритм Дейкстры для поиска кратчайших путей от вершины s до всех остальных
     * 
     * @param graph список смежности графа
     * @param s начальная вершина
     * @param n количество вершин
     * @return массив минимальных расстояний от s до всех вершин
     */
    public static long[] dijkstra(List<List<Edge>> graph, int s, int n) {
        // Массив для хранения минимальных расстояний
        long[] dist = new long[n + 1];
        Arrays.fill(dist, Long.MAX_VALUE);
        dist[s] = 0;
        
        // Массив для отслеживания посещенных вершин
        boolean[] visited = new boolean[n + 1];
        
        // Приоритетная очередь для выбора вершины с минимальным расстоянием
        PriorityQueue<Node> pq = new PriorityQueue<>();
        pq.add(new Node(s, 0));
        
        while (!pq.isEmpty()) {
            Node current = pq.poll();
            int u = current.vertex;
            
            // Если вершина уже обработана, пропускаем её
            if (visited[u]) {
                continue;
            }
            
            // Отмечаем вершину как посещенную
            visited[u] = true;
            
            // Перебираем всех соседей текущей вершины
            for (Edge edge : graph.get(u)) {
                int v = edge.to;
                int weight = edge.weight;
                
                // Если найден более короткий путь до v
                if (!visited[v] && dist[u] + weight < dist[v]) {
                    dist[v] = dist[u] + weight;
                    pq.add(new Node(v, dist[v]));
                }
            }
        }
        
        return dist;
    }
}
```
Подробное объяснение
Структуры данных
Edge - класс для представления ребра графа:

to - конечная вершина ребра
weight - вес ребра
Node - класс для хранения пары (вершина, расстояние) в приоритетной очереди:

vertex - номер вершины
distance - расстояние от начальной вершины до данной
Реализует интерфейс Comparable для сортировки по расстоянию
Представление графа:

Используем список смежности для представления графа
graph.get(u) содержит список всех рёбер, исходящих из вершины u
Алгоритм Дейкстры
Инициализация:

Создаем массив dist[] для хранения минимальных расстояний
Устанавливаем dist[s] = 0 для начальной вершины и dist[v] = Long.MAX_VALUE для всех остальных
Создаем массив visited[] для отслеживания посещенных вершин
Создаем приоритетную очередь pq и добавляем в неё начальную вершину s с расстоянием 0
Основной цикл:

Пока очередь не пуста:
Извлекаем вершину u с минимальным расстоянием из очереди
Если вершина уже обработана, пропускаем её
Отмечаем вершину как посещенную
Для каждого соседа v вершины u:
Если найден более короткий путь до v, обновляем dist[v] и добавляем v в очередь
Результат:

Массив dist[] содержит минимальные расстояния от s до всех вершин
Если dist[v] = Long.MAX_VALUE, то вершина v недостижима из s
Оптимизации
Проверка на посещенность:

Используем массив visited[] для отслеживания посещенных вершин
Это позволяет избежать повторной обработки вершин и уменьшить количество операций
Приоритетная очередь:

Используем PriorityQueue для эффективного выбора вершины с минимальным расстоянием
Это позволяет уменьшить временную сложность алгоритма до O((V + E) log V)
Пример работы алгоритма
Рассмотрим граф с 5 вершинами и 7 рёбрами:

1 -- 2 (вес 10)
|    |
|    |
3 -- 4 (вес 5)
\    /
\  /
5
Веса рёбер:

(1, 2): 10
(1, 3): 5
(2, 4): 1
(3, 4): 2
(3, 5): 6
(4, 5): 2
(5, 1): 7
Начальная вершина s = 1.

Инициализация:

dist = [0, 0, ∞, ∞, ∞, ∞]
visited = [false, false, false, false, false, false]
pq = [(1, 0)]
Итерация 1:

Извлекаем (1, 0) из pq
Отмечаем вершину 1 как посещенную
Обрабатываем соседей вершины 1:
Вершина 2: dist[2] = 0 + 10 = 10, добавляем (2, 10) в pq
Вершина 3: dist[3] = 0 + 5 = 5, добавляем (3, 5) в pq
dist = [0, 0, 10, 5, ∞, ∞]
pq = [(3, 5), (2, 10)]
Итерация 2:

Извлекаем (3, 5) из pq
Отмечаем вершину 3 как посещенную
Обрабатываем соседей вершины 3:
Вершина 4: dist[4] = 5 + 2 = 7, добавляем (4, 7) в pq
Вершина 5: dist[5] = 5 + 6 = 11, добавляем (5, 11) в pq
dist = [0, 0, 10, 5, 7, 11]
pq = [(4, 7), (2, 10), (5, 11)]
Итерация 3:

Извлекаем (4, 7) из pq
Отмечаем вершину 4 как посещенную
Обрабатываем соседей вершины 4:
Вершина 5: dist[5] = 7 + 2 = 9 < 11, обновляем dist[5] и добавляем (5, 9) в pq
dist = [0, 0, 10, 5, 7, 9]
pq = [(5, 9), (2, 10), (5, 11)]
Итерация 4:

Извлекаем (5, 9) из pq
Отмечаем вершину 5 как посещенную
Обрабатываем соседей вершины 5:
Вершина 1: dist[1] = 9 + 7 = 16 > 0, не обновляем
dist = [0, 0, 10, 5, 7, 9]
pq = [(2, 10), (5, 11)]
Итерация 5:

Извлекаем (2, 10) из pq
Отмечаем вершину 2 как посещенную
Обрабатываем соседей вершины 2:
Вершина 4: dist[4] = 10 + 1 = 11 > 7, не обновляем
dist = [0, 0, 10, 5, 7, 9]
pq = [(5, 11)]
Итерация 6:

Извлекаем (5, 11) из pq
Вершина 5 уже посещена, пропускаем
pq = []
Результат:

Минимальные расстояния от вершины 1 до всех остальных:
dist[1] = 0
dist[2] = 10
dist[3] = 5
dist[4] = 7
dist[5] = 9
Сложность алгоритма
Временная сложность: O((V + E) log V), где V - количество вершин, E - количество рёбер

Каждая вершина извлекается из приоритетной очереди не более одного раза: O(V log V)
Каждое ребро обрабатывается не более одного раза: O(E log V)
Общая сложность: O((V + E) log V)
Пространственная сложность: O(V + E)

O(V) для хранения массивов dist[] и visited[]
O(E) для хранения графа в виде списка смежности
O(V) для хранения приоритетной очереди в худшем случае
Заключение
Алгоритм Дейкстры является эффективным решением для поиска кратчайших путей от одной вершины до всех остальных во взвешенном графе с неотрицательными весами рёбер. Он широко применяется в различных областях, таких как навигационные системы, сетевая маршрутизация и т.д.

Ключевые моменты реализации:

Использование приоритетной очереди для эффективного выбора вершины с минимальным расстоянием
Отслеживание посещенных вершин для избежания повторной обработки
Обновление расстояний при нахождении более короткого пути
Если в графе могут быть отрицательные веса рёбер, то следует использовать алгоритм Беллмана-Форда, который имеет временную сложность O(V * E), но может работать с отрицательными весами (при отсутствии циклов отрицательного веса).