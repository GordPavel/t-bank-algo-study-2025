Решение: Поиск ближайшего нуля в динамическом массиве

Введение

В этой задаче нам нужно реализовать структуру данных для работы с массивом, изначально заполненным нулями, которая поддерживает два типа операций:
Установить значение элемента массива a[i] в 1
Найти ближайший к позиции i элемент со значением 0

Для эффективного решения этой задачи мы можем использовать структуру данных, которая позволяет быстро находить ближайший ноль. Одним из подходов является использование множества (TreeSet в Java) для хранения индексов элементов, равных нулю.

Реализация на Java

import java.util.*;

public class NearestZeroFinder {

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Считываем размер массива и количество запросов
        int n = scanner.nextInt(); // Размер массива
        int q = scanner.nextInt(); // Количество запросов
        
        // Создаем структуру данных для работы с массивом
        ZeroTracker tracker = new ZeroTracker(n);
        
        // Обрабатываем запросы
        for (int i = 0; i  zeroIndices; // Множество индексов элементов, равных 0
        
        /**
         Инициализация трекера для массива размера n
         */
        public ZeroTracker(int n) {
            isOne = new boolean[n];
            zeroIndices = new TreeSet();
            
            // Изначально все элементы равны 0
            for (int i = 0; i < n; i++) {
                isOne[i] = false;
                zeroIndices.add(i);
            }
        }
        
        /**
         Устанавливает значение a[index] = 1
         */
        public void setOne(int index) {
            // Если элемент уже равен 1, ничего не делаем
            if (isOne[index]) {
                return;
            }
            
            isOne[index] = true;
            zeroIndices.remove(index); // Удаляем индекс из множества нулей
        }
        
        /**
         Находит ближайший к позиции index элемент со значением 0
         Возвращает индекс ближайшего нуля или -1, если нулей нет
         */
        public int findNearestZero(int index) {
            // Если в массиве не осталось нулей
            if (zeroIndices.isEmpty()) {
                return -1;
            }
            
            // Если сам элемент равен 0
            if (!isOne[index]) {
                return index;
            }
            
            // Находим ближайший ноль слева от index
            Integer leftZero = zeroIndices.floor(index);
            
            // Находим ближайший ноль справа от index
            Integer rightZero = zeroIndices.ceiling(index);
            
            // Если нет нуля слева
            if (leftZero == null) {
                return rightZero;
            }
            
            // Если нет нуля справа
            if (rightZero == null) {
                return leftZero;
            }
            
            // Выбираем ближайший из двух нулей
            if (index - leftZero <= rightZero - index) {
                return leftZero;
            } else {
                return rightZero;
            }
        }
    }
}

Подробное объяснение

Структура данных

ZeroTracker:
isOne[] - булев массив, отслеживающий, равен ли элемент 1
zeroIndices - TreeSet для хранения индексов элементов, равных 0

TreeSet в Java - это реализация отсортированного множества на основе красно-черного дерева. Он поддерживает операции добавления, удаления и поиска за O(log n), а также предоставляет методы для поиска ближайших элементов:
floor(x) - возвращает наибольший элемент, не превосходящий x
ceiling(x) - возвращает наименьший элемент, не меньший x

Основные операции

setOne(index) - устанавливает значение a[index] = 1:
Если элемент уже равен 1, ничего не делаем
Иначе устанавливаем isOne[index] = true и удаляем индекс из множества zeroIndices
Сложность: O(log n)

findNearestZero(index) - находит ближайший к позиции index элемент со значением 0:
Если в массиве не осталось нулей, возвращаем -1
Если сам элемент равен 0, возвращаем index
Иначе находим ближайший ноль слева (floor) и справа (ceiling) от index
Выбираем ближайший из двух нулей
Сложность: O(log n)

Процесс работы алгоритма

Инициализация:
Создаем булев массив isOne, изначально заполненный значениями false (все элементы равны 0)
Создаем TreeSet zeroIndices и добавляем в него все индексы от 0 до n-1

Установка элемента в 1 (setOne(index)):
Если элемент уже равен 1, ничего не делаем
Иначе устанавливаем isOne[index] = true и удаляем index из множества zeroIndices

Поиск ближайшего нуля (findNearestZero(index)):
Если множество zeroIndices пусто, возвращаем -1 (нулей нет)
Если сам элемент равен 0 (не установлен в 1), возвращаем index
Иначе:
Находим ближайший ноль слева от index с помощью метода floor
Находим ближайший ноль справа от index с помощью метода ceiling
Если нет нуля слева, возвращаем ноль справа
Если нет нуля справа, возвращаем ноль слева
Если есть нули и слева, и справа, выбираем ближайший (с минимальной разницей |index - zeroIndex|)

Пример работы алгоритма

Рассмотрим массив размера 5, изначально заполненный нулями: [0, 0, 0, 0, 0]

setOne(2): [0, 0, 1, 0, 0]
isOne[2] = true
zeroIndices = {0, 1, 3, 4}

findNearestZero(2):
isOne[2] = true, значит элемент не равен 0
leftZero = 1 (ближайший ноль слева)
rightZero = 3 (ближайший ноль справа)
Расстояние до leftZero: 2-1 = 1
Расстояние до rightZero: 3-2 = 1
Расстояния равны, возвращаем leftZero = 1 (или можно rightZero, в зависимости от реализации)

setOne(1): [0, 1, 1, 0, 0]
isOne[1] = true
zeroIndices = {0, 3, 4}

findNearestZero(2):
isOne[2] = true, значит элемент не равен 0
leftZero = 0 (ближайший ноль слева)
rightZero = 3 (ближайший ноль справа)
Расстояние до leftZero: 2-0 = 2
Расстояние до rightZero: 3-2 = 1
Расстояние до rightZero меньше, возвращаем rightZero = 3

Сложность алгоритма

Временная сложность:
Инициализация: O(n)
Операция setOne: O(log n)
Операция findNearestZero: O(log n)
Для q операций: O(n + q log n)

Пространственная сложность: O(n) для хранения массива isOne и множества zeroIndices.

Заключение

Данное решение эффективно обрабатывает оба типа запросов, используя TreeSet для быстрого поиска ближайшего нуля. Благодаря свойствам TreeSet, мы можем находить ближайшие элементы за логарифмическое время, что делает решение эффективным даже для больших массивов и большого количества запросов.

Ключевая идея решения заключается в том, что мы храним индексы всех нулей в отсортированном множестве, что позволяет быстро находить ближайший ноль с помощью методов floor и ceiling.