# Петя решил посчитать количество способов достать из n его любимых шариков ровно k. Т.к. ответ может быть достаточно большим, то посчитайте его по простому модулю p. Время O(n `log p).

Давайте разберём задачу:

Пете нужно посчитать число способов выбрать ровно $$ k $$ шариков из $$ n $$, то есть биномиальный коэффициент $$ C_n^k $$ по модулю простого числа $$ p $$.  
Требуется алгоритм с асимптотикой $$ O(n + \log p) $$.

---

## Решение

### 1. Формула биномиального коэффициента

$$
C_n^k = \frac{n!}{k!(n-k)!}
$$

### 2. Вычисление по модулю $$ p $$

Если $$ p $$ — простое, то можно воспользоваться формулой:

$$
C_n^k \bmod p = \frac{n! \bmod p}{(k! \bmod p) \cdot ((n-k)! \bmod p)} \bmod p
$$

Чтобы делить по модулю $$ p $$, нужно умножить на обратные по модулю $$ p $$ значения $$ k! $$ и $$ (n-k)! $$.

### 3. Предварительный подсчёт факториалов

Посчитаем массивы:

- $$ fact[i] = i! \bmod p $$
- $$ invFact[i] = (i!)^{-1} \bmod p $$

Это делается за $$ O(n) $$ с помощью быстрого возведения в степень для обратного по модулю.

### 4. Быстрое возведение в степень

Обратный элемент по модулю $$ p $$ для числа $$ a $$ — это $$ a^{p-2} \bmod p $$ (по малой теореме Ферма).

---

## Реализация на Java

```java
import java.util.*;

public class BinomialMod {
    static int MOD = 1_000_000_007; // Пример простого модуля, замените на свой p

    // Быстрое возведение в степень по модулю
    static long pow(long a, long b, int mod) {
        long res = 1;
        a %= mod;
        while (b > 0) {
            if ((b & 1) == 1) res = (res * a) % mod;
            a = (a * a) % mod;
            b >>= 1;
        }
        return res;
    }

    // Предварительный подсчет факториалов и обратных факториалов
    static long[] fact, invFact;
    static void precompute(int n, int mod) {
        fact = new long[n + 1];
        invFact = new long[n + 1];
        fact[0] = 1;
        for (int i = 1; i <= n; i++)
            fact[i] = (fact[i - 1] * i) % mod;
        invFact[n] = pow(fact[n], mod - 2, mod);
        for (int i = n - 1; i >= 0; i--)
            invFact[i] = (invFact[i + 1] * (i + 1)) % mod;
    }

    // Вычисление биномиального коэффициента по модулю
    static long binom(int n, int k, int mod) {
        if (k < 0 || k > n) return 0;
        return (((fact[n] * invFact[k]) % mod) * invFact[n - k]) % mod;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt(), k = sc.nextInt(), p = sc.nextInt();
        precompute(n, p);
        System.out.println(binom(n, k, p));
    }
}
```

---

## Кратко по сложности

- Предварительный подсчёт факториалов и обратных — $$ O(n) $$
- Быстрое возведение в степень — $$ O(\log p) $$
- Итог: $$ O(n + \log p) $$

---

**Ответ:**  
Количество способов выбрать $$ k $$ шариков из $$ n $$ по модулю $$ p $$ можно найти за $$ O(n + \log p) $$ с помощью предварительного подсчёта факториалов и обратных по модулю.
