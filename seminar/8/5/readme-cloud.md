Решение задачи: Удаление минимального числа элементов для получения возрастающей последовательности

Задача
Задана последовательность чисел. Требуется удалить из нее минимальное число элементов, чтобы она стала возрастающей. Время O(n log n).

Решение

Эта задача эквивалентна нахождению наибольшей возрастающей подпоследовательности (Longest Increasing Subsequence, LIS). Если мы найдем LIS длиной L в последовательности длиной N, то минимальное количество элементов, которые нужно удалить, равно N - L.

Для решения задачи я буду использовать эффективный алгоритм нахождения LIS с временной сложностью O(n log n), основанный на методе терпеливой сортировки (Patience Sort).

import java.util.*;

public class MinimumDeletionsForIncreasingSequence {

    /**
     Находит минимальное количество элементов, которые нужно удалить,
     чтобы последовательность стала возрастающей.
     * @param nums исходная последовательность
     @return минимальное количество элементов для удаления
     */
    public static int minimumDeletions(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        
        int n = nums.length;
        
        // Находим длину наибольшей возрастающей подпоследовательности
        int lisLength = longestIncreasingSubsequenceLength(nums);
        
        // Минимальное количество элементов для удаления = общее количество - длина LIS
        return n - lisLength;
    }
    
    /**
     Находит длину наибольшей возрастающей подпоследовательности.
     Использует алгоритм с временной сложностью O(n log n).
     * @param nums исходная последовательность
     @return длина наибольшей возрастающей подпоследовательности
     */
    private static int longestIncreasingSubsequenceLength(int[] nums) {
        int n = nums.length;
        
        // Массив для хранения "стопок" в алгоритме терпеливой сортировки
        // tails[i] хранит наименьшее значение, которым может заканчиваться
        // возрастающая подпоследовательность длины i+1
        int[] tails = new int[n];
        
        // Изначально у нас нет ни одной стопки
        int size = 0;
        
        for (int num : nums) {
            // Бинарный поиск для нахождения позиции для текущего элемента
            int left = 0;
            int right = size;
            
            while (left  longestIncreasingSubsequence(int[] nums) {
        int n = nums.length;
        
        // Массив для хранения индексов элементов в стопках
        int[] tails = new int[n];
        
        // Массив для хранения предыдущего элемента в LIS
        int[] prev = new int[n];
        Arrays.fill(prev, -1);
        
        // Массив для хранения индексов элементов в стопках
        int[] indices = new int[n];
        
        int size = 0;
        
        for (int i = 0; i  0, то у текущего элемента есть предыдущий в LIS
            if (left > 0) {
                prev[i] = indices[left - 1];
            }
            
            // Помещаем текущий элемент в найденную позицию
            indices[left] = i;
            tails[left] = num;
            
            // Если мы добавили элемент в конец, увеличиваем размер
            if (left == size) {
                size++;
            }
        }
        
        // Восстанавливаем LIS
        List lis = new ArrayList();
        int index = indices[size - 1];
        
        while (index != -1) {
            lis.add(0, nums[index]);
            index = prev[index];
        }
        
        return lis;
    }
    
    /**
     Находит индексы элементов, которые нужно удалить, чтобы
     последовательность стала возрастающей.
     * @param nums исходная последовательность
     @return индексы элементов для удаления
     */
    public static List elementsToDelete(int[] nums) {
        List lis = longestIncreasingSubsequence(nums);
        List toDelete = new ArrayList();
        
        int lisIndex = 0;
        for (int i = 0; i  lis = longestIncreasingSubsequence(nums);
        List toDelete = elementsToDelete(nums);
        
        System.out.println("Минимальное количество элементов для удаления: " + minDeletions);
        System.out.println("Наибольшая возрастающая подпоследовательность: " + lis);
        System.out.println("Индексы элементов для удаления (0-indexed): " + toDelete);
        
        // Демонстрация результата
        System.out.print("Исходная последовательность: ");
        for (int num : nums) {
            System.out.print(num + " ");
        }
        System.out.println();
        
        System.out.print("Последовательность после удаления: ");
        for (int i = 0; i  2, поэтому tails = [2, 5], size = 2

num = 3:
3 > 2 и 3  3, поэтому tails = [2, 3, 7], size = 3

num = 101:
101 > 7, поэтому tails = [2, 3, 7, 101], size = 4

num = 18:
18 > 7 и 18  longestIncreasingSubsequence(int[] nums) {
int n = nums.length;

    // Массив для хранения индексов элементов в стопках
    int[] tails = new int[n];
    
    // Массив для хранения предыдущего элемента в LIS
    int[] prev = new int[n];
    Arrays.fill(prev, -1);
    
    // Массив для хранения индексов элементов в стопках
    int[] indices = new int[n];
    
    int size = 0;
    
    for (int i = 0; i  0, то у текущего элемента есть предыдущий в LIS
        if (left > 0) {
            prev[i] = indices[left - 1];
        }
        
        // Помещаем текущий элемент в найденную позицию
        indices[left] = i;
        tails[left] = num;
        
        // Если мы добавили элемент в конец, увеличиваем размер
        if (left == size) {
            size++;
        }
    }
    
    // Восстанавливаем LIS
    List lis = new ArrayList();
    int index = indices[size - 1];
    
    while (index != -1) {
        lis.add(0, nums[index]);
        index = prev[index];
    }
    
    return lis;
}

Объяснение модификации:

Мы добавляем два дополнительных массива:
prev[i] хранит индекс предыдущего элемента в LIS для элемента с индексом i
indices[i] хранит индекс элемента, который находится в позиции i в массиве tails

Когда мы находим позицию для текущего элемента, мы также обновляем информацию о его предыдущем элементе в LIS.

После обработки всех элементов, мы восстанавливаем LIS, начиная с последнего элемента и следуя по ссылкам prev.

6. Нахождение элементов для удаления

Чтобы найти элементы, которые нужно удалить, мы сравниваем исходную последовательность с найденной LIS:

public static List elementsToDelete(int[] nums) {
List lis = longestIncreasingSubsequence(nums);
List toDelete = new ArrayList();

    int lisIndex = 0;
    for (int i = 0; i < nums.length; i++) {
        if (lisIndex < lis.size() && nums[i] == lis.get(lisIndex)) {
            lisIndex++;
        } else {
            toDelete.add(i);
        }
    }
    
    return toDelete;
}

Объяснение:

Мы проходим по исходной последовательности и сравниваем каждый элемент с текущим элементом LIS.

Если элемент совпадает с текущим элементом LIS, мы переходим к следующему элементу LIS.

Если элемент не совпадает, мы добавляем его индекс в список элементов для удаления.

7. Временная сложность

Нахождение длины LIS: O(n log n)
Нахождение самой LIS: O(n log n)
Нахождение элементов для удаления: O(n)

Общая временная сложность: O(n log n)

8. Пространственная сложность

Массивы tails, prev, indices: O(n)
Списки lis, toDelete: O(n)

Общая пространственная сложность: O(n)

9. Пример использования

В функции main мы демонстрируем использование всех разработанных методов:
Находим минимальное количество элементов для удаления
Находим наибольшую возрастающую подпоследовательность
Находим индексы элементов для удаления
Демонстрируем результат, показывая исходную последовательность и последовательность после удаления

10. Дополнительные пояснения

Почему этот алгоритм работает?

Алгоритм основан на следующем наблюдении: если у нас есть возрастающая подпоследовательность длины k, заканчивающаяся на элементе с минимально возможным значением, то мы имеем больше шансов построить более длинную подпоследовательность в будущем.

Массив tails хранит именно такие "оптимальные" концы подпоследовательностей различных длин. Когда мы встречаем новый элемент, мы либо начинаем новую подпоследовательность, либо улучшаем существующую.

Почему бинарный поиск?

Бинарный поиск используется для эффективного нахождения позиции для текущего элемента в массиве tails. Поскольку массив tails всегда отсортирован (по построению), мы можем использовать бинарный поиск для нахождения позиции за O(log n) времени, вместо линейного поиска за O(n) времени.

Почему этот алгоритм лучше, чем динамическое программирование O(n^2)?

Классический алгоритм динамического программирования для нахождения LIS имеет временную сложность O(n^2), так как для каждого элемента мы проверяем все предыдущие элементы. Алгоритм, использующий бинарный поиск, имеет временную сложность O(n log n), что значительно эффективнее для больших последовательностей.