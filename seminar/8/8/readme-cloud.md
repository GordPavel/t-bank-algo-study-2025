Решение задачи 8: Нахождение количества суперинверсий размера k

Задача: Дан массив из n элементов. Требуется найти количество суперинверсий размера k, т.е. количество таких наборов индексов 1 ≤ i₁  a[i₂] > ... > a[iₖ].

Решение (a): Время O(k·n²)

Сначала рассмотрим решение с временной сложностью O(k·n²), которое использует динамическое программирование:

public class SuperInversionsNaive {
public static long countSuperInversions(int[] arr, int k) {
int n = arr.length;

        // dpi - количество убывающих последовательностей длины i,
        // заканчивающихся на элементе с индексом j
        long dp = new longk + 1;
        
        // Базовый случай: последовательности длины 1
        for (int j = 0; j  arr[j]) {
                        dpi += dpi-1;
                    }
                }
            }
        }
        
        // Суммируем количество последовательностей длины k по всем конечным элементам
        long result = 0;
        for (int j = 0; j  arr[j], то можем добавить arr[j] к последовательностям длины i-1, заканчивающимся на arr[l]
Увеличиваем dpi на dpi-1
Итоговый результат - сумма dpk для всех j.

Временная сложность: O(k·n²), так как у нас k итераций по i, и для каждой итерации мы перебираем все пары индексов (j, l), где j и l от 0 до n-1.
Пространственная сложность: O(k·n) для хранения таблицы dp.

Решение (b): Время O(k·n·log n)

Для более эффективного решения можно использовать структуру данных, которая позволяет быстро находить количество элементов, больших заданного. Такой структурой может быть дерево Фенвика (Binary Indexed Tree) или дерево отрезков (Segment Tree).

public class SuperInversionsEfficient {
// Класс для представления дерева Фенвика (Binary Indexed Tree)
static class FenwickTree {
private long[] tree;

        public FenwickTree(int size) {
            tree = new long[size + 1];
        }
        
        // Обновление значения в дереве
        public void update(int idx, long val) {
            while (idx  0) {
                sum += tree[idx];
                idx -= idx & -idx; // Переход к предыдущему индексу в дереве
            }
            return sum;
        }
    }
    
    public static long countSuperInversions(int[] arr, int k) {
        int n = arr.length;
        
        // Сжатие координат для работы с деревом Фенвика
        int[] sortedArr = arr.clone();
        Arrays.sort(sortedArr);
        Map compress = new HashMap();
        for (int i = 0; i  4
Для arr[2] = 3: есть 1 последовательность длины 2, заканчивающаяся на элементах > 3 (5,4)
Для arr[3] = 2: есть 3 последовательности длины 2, заканчивающиеся на элементах > 2
Для arr[4] = 1: есть 6 последовательностей длины 2, заканчивающихся на элементах > 1
Итого: 0 + 0 + 1 + 3 + 6 = 10 суперинверсий размера 3

Этот алгоритм значительно эффективнее наивного подхода для больших массивов и больших значений k.