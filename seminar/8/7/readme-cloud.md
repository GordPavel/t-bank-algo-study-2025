Решение задачи 7: Нахождение количества инверсий в массиве

Задача: Дан массив из n элементов. Требуется найти в нём количество инверсий.

Инверсия в массиве - это пара элементов (a[i], a[j]), где i  a[j]. Другими словами, это пара элементов, которые стоят в неправильном порядке с точки зрения сортировки по возрастанию.

Решение (a): Время O(n²)

Сначала рассмотрим простое решение с временной сложностью O(n²):

public class InversionCountNaive {
public static long countInversions(int[] arr) {
long inversions = 0;
int n = arr.length;

        // Перебираем все пары элементов
        for (int i = 0; i  arr[j]) {
                    inversions++;
                }
            }
        }
        
        return inversions;
    }
    
    public static void main(String[] args) {
        int[] arr = {8, 4, 2, 1};
        System.out.println("Количество инверсий: " + countInversions(arr));
    }
}

Объяснение:
Используем два вложенных цикла для перебора всех возможных пар элементов.
Для каждой пары (i, j), где i  a[j].
Если условие выполняется, увеличиваем счетчик инверсий.

Временная сложность: O(n²), так как мы перебираем все пары элементов.
Пространственная сложность: O(1), используется только константное дополнительное пространство.

Решение (b): Время O(n log n)

Для более эффективного решения можно использовать модификацию алгоритма сортировки слиянием (Merge Sort). Идея в том, что количество инверсий связано с количеством перестановок, необходимых для сортировки массива.

public class InversionCountEfficient {
private static long mergeAndCount(int[] arr, int[] temp, int left, int mid, int right) {
long inversions = 0;

        // i - индекс для левой части, j - для правой
        int i = left;
        int j = mid + 1;
        int k = left; // индекс для временного массива
        
        while (i  4)
Рекурсивно обрабатываем [2, 1]:
Разделяем на [2] и [1]
Слияние [2] и [1] дает [1, 2] и 1 инверсию (2 > 1)
Слияние [4, 8] и [1, 2] дает [1, 2, 4, 8] и 4 инверсии (4 > 1, 4 > 2, 8 > 1, 8 > 2)
Итого: 1 + 1 + 4 = 6 инверсий

Временная сложность: O(n log n), так как используется алгоритм сортировки слиянием.
Пространственная сложность: O(n) для временного массива.

Этот алгоритм значительно эффективнее наивного подхода, особенно для больших массивов.