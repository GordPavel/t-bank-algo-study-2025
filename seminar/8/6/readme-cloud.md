Решение задачи: Подсчет точек в прямоугольниках

Задача
Даны n прямоугольников и m точек. Для каждого прямоугольника требуется определить, сколько из данных m точек лежат внутри этого прямоугольника. Время O((n + m) log(n + m)).

Решение

Для решения этой задачи я буду использовать метод сканирующей прямой (sweep line) в сочетании с деревом поиска для эффективного подсчета точек внутри прямоугольников.

import java.util.*;

public class PointsInRectangles {

    // Класс для представления прямоугольника
    static class Rectangle {
        int id;         // Идентификатор прямоугольника
        int x1, y1;     // Левый нижний угол
        int x2, y2;     // Правый верхний угол
        
        public Rectangle(int id, int x1, int y1, int x2, int y2) {
            this.id = id;
            this.x1 = x1;
            this.y1 = y1;
            this.x2 = x2;
            this.y2 = y2;
        }
    }
    
    // Класс для представления точки
    static class Point {
        int id;         // Идентификатор точки
        int x, y;       // Координаты
        
        public Point(int id, int x, int y) {
            this.id = id;
            this.x = x;
            this.y = y;
        }
    }
    
    // Класс для представления события сканирующей прямой
    static class Event implements Comparable {
        int x;          // x-координата события
        int type;       // Тип события: 0 - левая сторона прямоугольника, 1 - точка, 2 - правая сторона прямоугольника
        int id;         // Идентификатор прямоугольника или точки
        int y1, y2;     // Для прямоугольника: y-координаты нижней и верхней сторон
        int y;          // Для точки: y-координата
        
        // Конструктор для события прямоугольника (левая или правая сторона)
        public Event(int x, int type, int id, int y1, int y2) {
            this.x = x;
            this.type = type;
            this.id = id;
            this.y1 = y1;
            this.y2 = y2;
        }
        
        // Конструктор для события точки
        public Event(int x, int type, int id, int y) {
            this.x = x;
            this.type = type;
            this.id = id;
            this.y = y;
        }
        
        // Сравнение событий для сортировки
        @Override
        public int compareTo(Event other) {
            if (this.x != other.x) {
                return Integer.compare(this.x, other.x);
            }
            // При одинаковых x-координатах сначала обрабатываем левые стороны прямоугольников,
            // затем точки, затем правые стороны прямоугольников
            return Integer.compare(this.type, other.type);
        }
    }
    
    // Класс для представления интервала в дереве интервалов
    static class Interval {
        int start, end;  // Начало и конец интервала
        
        public Interval(int start, int end) {
            this.start = start;
            this.end = end;
        }
        
        // Проверка, содержит ли интервал точку
        public boolean contains(int point) {
            return point >= start && point = interval.end) {
                node.count++;
                return;
            }
            
            // Если интервалы не пересекаются
            if (start > interval.end || end = interval.end) {
                node.count--;
                return;
            }
            
            // Если интервалы не пересекаются
            if (start > interval.end || end  point)) {
                return node.count;
            }
            
            // Рекурсивно ищем в дочерних узлах
            int count = node.count; // Учитываем интервалы, полностью содержащие текущий узел
            
            if (point  events = new ArrayList();
        
        // Добавляем события для левых и правых сторон прямоугольников
        for (int i = 0; i  0) {
                    for (int i = 0; i  events = new ArrayList();
        
        // Добавляем события для левых и правых сторон прямоугольников
        for (int i = 0; i  activeRectangles = new HashSet();
        
        // Обрабатываем события
        for (Event event : events) {
            if (event.type == 0) {
                // Левая сторона прямоугольника - добавляем прямоугольник в активные
                activeRectangles.add(event.id);
            } else if (event.type == 1) {
                // Точка - проверяем, содержится ли она в активных прямоугольниках
                Point point = points[event.id];
                
                for (int rectId : activeRectangles) {
                    Rectangle rect = rectangles[rectId];
                    if (point.y >= rect.y1 && point.y  {
    int x;          // x-координата события
    int type;       // Тип события: 0 - левая сторона прямоугольника, 1 - точка, 2 - правая сторона прямоугольника
    int id;         // Идентификатор прямоугольника или точки
    int y1, y2;     // Для прямоугольника: y-координаты нижней и верхней сторон
    int y;          // Для точки: y-координата
    
    // Конструктор для события прямоугольника (левая или правая сторона)
    public Event(int x, int type, int id, int y1, int y2) {
        this.x = x;
        this.type = type;
        this.id = id;
        this.y1 = y1;
        this.y2 = y2;
    }
    
    // Конструктор для события точки
    public Event(int x, int type, int id, int y) {
        this.x = x;
        this.type = type;
        this.id = id;
        this.y = y;
    }
    
    // Сравнение событий для сортировки
    @Override
    public int compareTo(Event other) {
        if (this.x != other.x) {
            return Integer.compare(this.x, other.x);
        }
        // При одинаковых x-координатах сначала обрабатываем левые стороны прямоугольников,
        // затем точки, затем правые стороны прямоугольников
        return Integer.compare(this.type, other.type);
    }
}

Я определил три класса:
Rectangle - для хранения информации о прямоугольнике
Point - для хранения информации о точке
Event - для представления событий сканирующей прямой (левая сторона прямоугольника, точка, правая сторона прямоугольника)

4. Дерево интервалов (для первого решения)

// Класс для представления интервала в дереве интервалов
static class Interval {
int start, end;  // Начало и конец интервала

    public Interval(int start, int end) {
        this.start = start;
        this.end = end;
    }
    
    // Проверка, содержит ли интервал точку
    public boolean contains(int point) {
        return point >= start && point = interval.end) {
            node.count++;
            return;
        }
        
        // Если интервалы не пересекаются
        if (start > interval.end || end = interval.end) {
            node.count--;
            return;
        }
        
        // Если интервалы не пересекаются
        if (start > interval.end || end  point)) {
            return node.count;
        }
        
        // Рекурсивно ищем в дочерних узлах
        int count = node.count; // Учитываем интервалы, полностью содержащие текущий узел
        
        if (point  events = new ArrayList();
    
    // Добавляем события для левых и правых сторон прямоугольников
    for (int i = 0; i  0) {
                for (int i = 0; i  events = new ArrayList();
    
    // Добавляем события для левых и правых сторон прямоугольников
    for (int i = 0; i  activeRectangles = new HashSet();
    
    // Обрабатываем события
    for (Event event : events) {
        if (event.type == 0) {
            // Левая сторона прямоугольника - добавляем прямоугольник в активные
            activeRectangles.add(event.id);
        } else if (event.type == 1) {
            // Точка - проверяем, содержится ли она в активных прямоугольниках
            Point point = points[event.id];
            
            for (int rectId : activeRectangles) {
                Rectangle rect = rectangles[rectId];
                if (point.y >= rect.y1 && point.y <= rect.y2) {
                    result[rectId]++;
                }
            }
        } else {
            // Правая сторона прямоугольника - удаляем прямоугольник из активных
            activeRectangles.remove(event.id);
        }
    }
    
    return result;
}

Это решение проще и более понятно. Вместо использования дерева интервалов, мы просто поддерживаем множество активных прямоугольников и для каждой точки проверяем, содержится ли она в каждом из активных прямоугольников.

7. Временная сложность

Для обоих решений:
Сортировка событий: O((n + m) log(n + m))
Обработка событий:
Первое решение: O((n + m) log(n + m))
Второе решение: O(n * m) в худшем случае (если все прямоугольники активны для всех точек)

Общая временная сложность:
Первое решение: O((n + m) log(n + m))
Второе решение: O((n + m) log(n + m) + n * m) в худшем случае

Второе решение может быть менее эффективным в худшем случае, но оно проще и более понятно. В среднем случае, когда не все прямоугольники активны для всех точек, оно может работать достаточно эффективно.

8. Пространственная сложность

Хранение прямоугольников и точек: O(n + m)
Хранение событий: O(n + m)
Дерево интервалов (для первого решения): O(n)
Множество активных прямоугольников (для второго решения): O(n)

Общая пространственная сложность: O(n + m)

9. Пример использования

В функции main я реализовал интерактивный интерфейс для работы с прямоугольниками и точками:
Пользователь вводит количество прямоугольников и их координаты
Затем пользователь вводит количество точек и их координаты
Программа вычисляет и выводит количество точек в каждом прямоугольнике

10. Дополнительные пояснения

Почему мы используем метод сканирующей прямой?

Метод сканирующей прямой позволяет эффективно обрабатывать геометрические задачи, сводя двумерную задачу к одномерной. Вместо того, чтобы рассматривать всю плоскость сразу, мы "сканируем" ее слева направо, обрабатывая события в порядке их x-координат.

Почему мы сортируем события по типу при одинаковых x-координатах?

Порядок обработки событий с одинаковыми x-координатами важен:
Сначала обрабатываем левые стороны прямоугольников (добавляем их в активные)
Затем обрабатываем точки (проверяем, содержатся ли они в активных прямоугольниках)
Наконец, обрабатываем правые стороны прямоугольников (удаляем их из активных)

Это гарантирует, что точка будет правильно учтена, если она лежит на границе прямоугольника.

Почему во втором решении мы добавляем +1 к x-координате правой стороны прямоугольника?

Это делается для корректной обработки точек, лежащих на правой границе прямоугольника. Добавляя +1, мы гарантируем, что прямоугольник будет считаться активным для всех точек с x-координатой, меньшей или равной x2.

Какое решение лучше?

Выбор между первым и вторым решением зависит от конкретных условий задачи:
Если n и m примерно одинаковы и не очень велики, второе решение может быть предпочтительнее из-за своей простоты
Если n << m (количество прямоугольников намного меньше количества точек), второе решение может быть эффективнее
Если m << n (количество точек намного меньше количества прямоугольников), первое решение с деревом интервалов может быть более эффективным

В большинстве практических случаев второе решение будет достаточно эффективным и более простым в реализации.